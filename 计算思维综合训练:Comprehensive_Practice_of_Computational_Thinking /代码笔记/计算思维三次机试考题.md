# 计算思维三次机试考题

### 第一次机试

#### A

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20230612131831625.png" alt="image-20230612131831625" style="zoom:50%;" />

```c
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1e5 + 10;
long long a[N];
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
    {
        scanf("%lld", &a[i]);
    }
    //排序
    sort(a, a + n);
    //取两最大两最小
    long long a1 = a[0] * a[1];
    long long a2 = a[n - 1] * a[n - 2];
    //比较并输出
    if(a1>a2)
        printf("%lld\n",a1);
    else
        printf("%lld\n",a2);
    return 0;
}
```

#### E

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20230612131945299.png" alt="image-20230612131945299" style="zoom:50%;" />

```c
#include<iostream>
const int N=1e5;
//a是桶
int a[N];
int b[110];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=0;i<n;i++)
    {
        scanf("%d",&b[i]);
    }
    //所有两数和存在桶里
    for(int i=0;i<n;i++)
        for(int j=i+1;j<n;j++)
            a[b[i]+b[j]]=1;
    int ans=0;
    //通过桶确认是否存在满足条件的数
    for(int i=0;i<n;i++)
    {
        if(a[b[i]]==1)
            ans++;
    }
    printf("%d\n",ans);
}
```

### 第二次机试

#### D

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20230612132546448.png" alt="image-20230612132546448" style="zoom:50%;" />

```c
#include<iostream>
using namespace std;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        long long n;
        scanf("%lld",&n);
        //n的副本，便于操作
        long long n1=n;
        int sum=0;
        //使用/10和%10来获取每一数位的数字
        while(n1)
        {
            sum += n1%10;
            n1 /= 10;
        }
        bool flag=1;
        //判断是否是质数
        for(int i=2;i*i<=sum;i++)
        {
            if(sum%i==0)
            {
                flag=0;
                break;
            }
        }
        //1和2单独判断
        if(sum==2)
            flag=1;
        if(sum==1)
            flag=0;
        //是否满足题设条件
        if(flag==1&&n%sum==0)
        {
            printf("Yes\n");
        }
        else
            printf("No\n");
    }
}
```

#### A

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20230612132807319.png" alt="image-20230612132807319" style="zoom:50%;" />

```c
/*将a分成两个区间，找出左区间的最小值和右区间的最大值
二者之差的最大值乘以m即为答案
如何查找？每次都遍历：O(n2)，超时！
通过数组维护最小值和最大值，遍历两次即可，类似前缀和
left_min[i]：a[1]~a[i]中的最小值，从前往后遍历
right_max[i]：a[i]~a[n]中的最大值，从后往前遍历
答案：ans = max(ans, LL(right_max[i + 1] - left_min[i]) * m);
*/
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long LL;

const int N = 1e6 + 10;

int n, m;
int a[N];
int back_max[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        scanf("%d", &a[i]);
    //back_max[i]存的是i～n的最大值
    for (int i = n; i >= 1; i--)
    {
        //如果a[i]比i+1～n的最大值还大，那么a[i]作为新的最大值
        if (a[i] > back_max[i + 1])
            back_max[i] = a[i];
        //如果a[i]并没有i+1~n的最大值大，则最大值还是i+1~n的最大值
        else
            back_max[i] = back_max[i + 1];
    }
    LL ans = 0;
    //每个位置和后面所有数字最大值的差，都遍历一遍就可以找到最大值了
    for (int i = 1; i <= n - 1; i++)
        ans = max(ans, LL(back_max[i + 1]-a[i]) * m);
    printf("%lld\n", ans);
    return 0;
}
```

#### B

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20230612133012784.png" alt="image-20230612133012784" style="zoom:50%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20230612133025168.png" alt="image-20230612133025168" style="zoom:50%;" />

```c
第一次用自己完全使用map去解题目，对map中的key和value有了一个更深的理解
unordered_map<key, value>		//是用key去找value
duck_names.insert({ str, i });	//用insert去插入key和value
判断是否是duck_names里面的元素duck_names.count(str)
duck_names[str]通过key去访问value
cnt[duck_names[str]]++;运用了桶的思想
```

```c
#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<iostream>
#include<algorithm>
#include<unordered_map>
using namespace std;

const int N = 1e5 + 10;
int cnt[N];
int cnt0[N];

int main(void)
{
	int a, b, t,Max1,Max2;
	char str[100];
	unordered_map<string, int>duck_names;
	unordered_map<string, int>goose_names;

	scanf("%d %d", &a, &b);

	for (int i = 0; i < a; i++)
	{
		scanf("%s", str);
		duck_names.insert({ str, i });
	}

	for (int i = a; i < b+a; i++)
	{
		scanf("%s", str);
		goose_names.insert({ str,i });
	}

	for (int i = 0; i < b; i++)
	{
		scanf("%s", str);

		if (duck_names.count(str))
		{
			int value = duck_names[str];
			cnt[value]++;
		}
		else if (goose_names.count(str))
		{
			int value = goose_names[str];
			cnt[value]++;
		}
		else//如果是跳过的
		{
			cnt[a + b]++;
		}
	}

	Max1 = cnt[0];
	Max2 = cnt[1];

	for (int i = 0; i <= a + b; i++)
	{
		if (cnt[i] > Max1)
			Max1 = cnt[i];
		else if (cnt[i] > Max2)
			Max2 = cnt[i];
	}

	scanf("%d", &t);

	for (int i = 0; i < t; i++)
	{
		scanf("%s", str);

		if (duck_names.count(str))	//如果是鸭子阵营，则需要保护
		{
			if (cnt[duck_names[str]] <= Max1 + a)
				printf("Yes\n");
			else
				printf("No\n");
		}
		else if (goose_names.count(str))	//鹅的阵营，全票出
		{
			if (cnt[goose_names[str]] + a <= Max1)
				printf("No\n");
			else if (cnt[goose_names[str]] + a > Max1)
				printf("Yes\n");
		}
		else //跳过票数，判断是否少于Max1且最高票没有平票
		{
			if (cnt[a + b + 1] + a > Max1)
				printf("Yes\n");
			else if (cnt[a + b + 1] + a == Max1)
				printf("Yes\n");
			else if (Max1 == Max2)
				printf("Yes\n");
			else
				printf("No\n");
		}
	}
}
```

#### C

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20230612133202083.png" alt="image-20230612133202083" style="zoom:50%;" />

```c
/*难度最大，可以考虑水部分分
三层循环：枚举所有区间，然后枚举区间内的所有值，27分
两层循环：枚举所有区间，用前缀和优化第三层循环，55分

AC解法
如果区间[1, l]和区间[1, r]的AC与WA之差的个数相同，则区间[l+1, r]的AC与WA个数相同
桶记录前i个成绩中，AC与WA之差相同的区间个数，ans+=bucket[ac-wa]
时间复杂度O(n)*/
```

```c
#include <iostream>
#include <unordered_map>

using namespace std;
unordered_map<long long, long long> m;
int main()
{
    int n;
    scanf("%d", &n);
    int score;
    m[0] = 1;
    long long ans = 0;
    long long ac = 0;
    long long wa = 0;
    // 对于每一个状态，如前k个的AC比WA多一个，前l个的AC也比WA多一个，
    // 假设l>k，则l-k得到的区间的WA和AC数量相同
    // 利用这个思路，我们得到每个状态当前的数量，进行更新维护并增加答案即可
    while (n--)
    {
        scanf("%d", &score);
        //当前是AC还是WA，即当前，前i个里面的AC和WA的数量
        if (score == 100)
            ac++;
        else
            wa++;
        //ac-wa是一个状态，如果状态相同，则和上文说的一致
        //如果已经存在j个ac-wa的状态，则当前前缀减去这j个前缀得到的区间
        //都满足AC和WA数量相同，所以答案增加j
        ans += m[ac-wa];
        //当前前缀和ac-wa需要增加1
        m[ac-wa]++;
    }
    printf("%lld\n",ans);
    return 0;
}
```

### 第三次机试

#### F

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20230612133800803.png" alt="image-20230612133800803" style="zoom:50%;" />

```c
#include<iostream>
#include<set>
#include<unordered_map>

using namespace std;
// 这种题讲了三道类似的了一个第一次机试的A+B，一个是洛谷的A-B数对，一个是习题课讲的Average
// 核心思路就是桶，当作桶的容器是map/unordered_map，去重可以用set
// 桶和map很重要，实在不会再去复习一下A-B数对！！！！

int main()
{
    int n;
    long long a[1010];
    while(scanf("%d",&n)!=EOF)
    {
        int ans = 0;
        // 因为多组输入，因此声明循环内的局部变量，这样每一组都是新变量，不需要清空
        set<long long> nums;
        unordered_map<long long,long long> b;
        for(int i=0;i<n;i++)
        {
            scanf("%lld",&a[i]);
            // 读入数据的同时插入set完成去重
            nums.insert(a[i]);
        }
        for(int i=0;i<n;i++)
            for(int j=i+1;j<n;j++)
            {
                // 因为题目问的是符合条件的数字有多少个，
                // 因此存平均数、查数字是一个很好的办法
                // 由于题意可知，当两数和为奇数时不考虑，因此加判断，切忌给奇数取整然后算上了
                if((a[i]+a[j])%2==0)
                    b[(a[i]+a[j])/2]=1;
            }
        // 直接遍历set查符合条件的数
        for(auto i = nums.begin();i!=nums.end();i++)
        {
            // 这里用find，防止直接访问插入过多元素导致超时
            if(b.find(*i)!=b.end())
                ans++;
        }
        printf("%d\n",ans);
    }
}
```

