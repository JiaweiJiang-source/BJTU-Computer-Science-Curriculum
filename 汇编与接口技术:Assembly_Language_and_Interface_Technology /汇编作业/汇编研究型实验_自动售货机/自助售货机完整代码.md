```assembly
stack1 segment
    dw 200 dup(?)
stack1 ends

data segment

    goods_num1 db 5;记录自动售货机内商品1的数量，初始值为50，每次补货自动补满
    goods_num2 db 5;商品2的数量
    goods_num3 db 5;商品3的数量
    goods_num4 db 5;商品4的数量

    number db ?;记录当前用户所要购买的商品

    ;中断部分相关参数
    int_off dw ?
    int_seg dw ?

    ;led显示相关参数
 PORTA EQU 288H;8255A端口地址


;文字GBK编码 提示用户键入1开始购买
    HZ_GUID DW 0C7EBH,0CAE4H,0C8EBH,0A2B1H,0C9EAH,0C7EBH,0B9BAH,0C2F2H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H;"请输入1申请购买"
    HZ_GUID_ADR DB ?
;LCD显示商品信息
    HZ_GOODS DW 0C9CCH,0C6B7H,0A2B1H,0A3A0H ;"商品1 2.商品2 商品3 商品4"
                         DW 0C9CCH,0C6B7H,0A2B2H,0A3A0H 
                         DW 0C9CCH,0C6B7H,0A2B3H,0A3A0H 
                         DW 0C9CCH,0C6B7H,0A2B4H,0A3A0H 
    HZ_GOODS_ADR DB ?
;LCD提示该商品售罄
    HZ_OUT DW 0A3A0H,0B8C3H,0C9CCH,0C6B7H,0D2D1H,0CADBH,0BFD5H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H;"该商品已售空”
    HZ_OUT_ADR DB ?
; 拿取货物成功提醒
    HZ_TAKE_success DW 0A3A0H,0C4C3H,0C8A1H,0C9CCH,0C6B7H,0B3C9H,0B9A6H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H;"拿取商品成功”
    HZ_TAKE_success_ADR DB ?
; 拿取货物提醒
    HZ_TAKE DW 0A3A0H,0C7EBH,0C4C3H,0C8A1H,0C9CCH,0C6B7H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H;"请拿取商品”
    HZ_TAKE_ADR DB ?
; 补货中...
    HZ_REC DW 0A3A0H,0B2B9H,0BBF5H,0D6D0H,0A1D1H,0A1D0H,0A1D1H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H;”补货中⊙⌒⊙”
    HZ_REC_ADR DB ?
;文字GBK编码 清屏操作
    HZ_CLEAR DW 0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H,0A3A0H;
    HZ_CLEAR_ADR DB ?

data ends

code segment
    assume cs:code, ds:data, es:data, ss:stack1
    ; 设置段寄存器的默认段，汇编器可以正确解释和生成代码

start:
    mov ax, data   ; 将数据段的段地址加载到AX寄存器
    mov ds, ax     ; 将AX寄存器的值移动到DS寄存器，设置数据段
    mov es, ax     ; 将AX寄存器的值移动到ES寄存器，设置额外段

    mov ax, stack1 ; 将堆栈段的段地址加载到AX寄存器
    mov ss, ax     ; 将AX寄存器的值移动到SS寄存器，设置堆栈段


;初始化8255为方式0
    mov dx,PORTA
    mov al,10000000b;用A口连接LED灯实现提示语输出功能
    out dx,al

; 判断键盘是否有购物请求
wait1:
    call SHOW_LCD_CLEAR ; 调用子程序清空LCD屏幕

    call SHOW_GUIDANCE ; 调用子程序在LCD显示提示用户键入1发送购物请求

    ; mov ah,0bh
    ; int 21h
    ; cmp al,0h
    ; je wait1 ; 如果没有键按下，继续等待（注释掉的部分，暂不执行）

    ; 判断按下的键是不是1
    mov ah,08h       ; 功能代码08h，用于等待键盘输入
    int 21h          ; 调用BIOS中断21h以获取键盘输入
    cmp al,31h       ; 比较AL寄存器中的值是否为ASCII码‘1’（31h）
    je choose_goods  ; 如果是‘1’，则跳转到choose_goods标签，进入限时货物选择部分

    ; 判断是否按下应急按钮（Esc）
    ; mov ah,08h
    ; int 21h         ; 获取按下的键（这两行被注释掉，不执行）
    cmp al,1bh       ; 比较AL寄存器中的值是否为ASCII码‘Esc’（1Bh）
    je urgent        ; 如果是‘Esc’，则跳转到urgent标签，进入紧急处理部分
    jmp wait1        ; 如果按下的不是‘1’或‘Esc’，则跳转回wait1标签，继续等待

; 紧急处理部分开始
urgent:
    call SHOW_LCD_CLEAR ; 调用子程序清空LCD屏幕
    call SHOW_RECOVER   ; 调用子程序在LCD显示恢复信息

    mov cx,05fh         ; 将0x5F（十进制95）加载到CX寄存器，用于循环计数
dll_RECOVER:
    call DELAY1         ; 调用延时子程序DELAY1
    loop dll_RECOVER    ; 循环执行，直到CX减为0，进行95次延时//loop 指令会将 CX 寄存器的值减1

    ; 进行中断处理
    call INT1           ; 调用中断处理子程序INT1
    mov al,5            ; 将数字5加载到AL寄存器
   
    ; 重置商品数量
    mov goods_num1,al   ; 将AL寄存器的值（5）加载到goods_num1，重置商品1的数量为5
    mov goods_num2,al   ; 将AL寄存器的值（5）加载到goods_num2，重置商品2的数量为5
    mov goods_num3,al   ; 将AL寄存器的值（5）加载到goods_num3，重置商品3的数量为5
    mov goods_num4,al   ; 将AL寄存器的值（5）加载到goods_num4，重置商品4的数量为5

    jmp wait1           ; 跳转回wait1标签，继续等待用户指令
; 紧急处理部分结束

;限时货物选择部分开始
choose_goods:

    call SHOW_LCD_CLEAR ;  有请求，清空LCD屏幕    

    ;LCD显示货物编号及库存，供用户进行选择
    call SHOW_GOODS
 
	; 倒计时5分钟开始，采用级联，用到8254进行计时
    ; 分别采用2方式（分频器）和0方式（结束即中断）
    ; out0输出作输入
    mov dx,283h           ; 设置DX为8253计数器控制端口地址
    mov al,00000000b      ; 选择计数器0，模式0，二进制计数
    out dx,al             ; 输出控制字到计数器0
    mov al,00110100b      ; 选择计数器0，模式2，二进制计数
    out dx,al             ; 输出控制字到计数器0
    mov dx,280h           ; 设置DX为计数器0的数据端口地址
    mov ax,10000          ; 设定计数初值为10000
    out dx,al             ; 输出低8位
    mov al,ah             ; 获取高8位
    out dx,al             ; 输出高8位

    mov dx,283h           ; 设置DX为计数器控制端口地址
    mov al,10110000b      ; 选择计数器2，模式0，二进制计数
    out dx,al             ; 输出控制字到计数器2
    mov ax,1000           ; 设定计数初值为1000
    mov dx,282h           ; 设置DX为计数器2的数据端口地址
    out dx,al             ; 输出低8位
    mov al,ah             ; 获取高8位
    out dx,al             ; 输出高8位
    ; 计时部分代码结束

;保护现场
 
choosing:
    ; 判断当前out是不是高电平（高电平代表计时结束）
    ; 如果计时结束， jmp wait，从头再来
    ; 一次性读取一个通道2的值，比较寄存器2为0
    mov dx,283h           ; 设置DX为计数器控制端口地址
    mov al,10000000b      ; 选择计数器0的读回命令
    out dx,al             ; 输出控制字到计数器0
    mov dx,282h           ; 设置DX为计数器2的数据端口地址
    in al,dx              ; 从计数器2读取低8位
    mov bl,al             ; 存储在BL中
    in al,dx              ; 从计数器2读取高8位
    mov bh,al             ; 存储在BH中

    cmp bx,0              ; 比较BX是否为0
    
    je wait1              ; 如果BX为0，跳转到wait1，从头开始
    ; 恢复现场

    mov ah,0bh            ; 设置AH为0bh，检查键盘缓冲区状态
    int 21h               ; 调用BIOS中断21h
    cmp al,0h             ; 比较AL是否为0（无键按下）
    je choosing           ; 如果无键按下，跳转到choosing，继续选择

    jmp is_1              ; 跳转到is_1标签
    
do_again:
    jmp wait1 ; 跳转回wait1标签，继续等待用户指令

; 判断按下的键是不是1
is_1:
    mov ah,08h        ; 功能代码08h，用于等待键盘输入
    int 21h           ; 调用BIOS中断21h以获取键盘输入
    cmp al,31h        ; 比较AL寄存器中的值是否为ASCII码‘1’（31h）
    jne is_2          ; 如果不是‘1’，则跳转到is_2，继续判断是不是2
    mov al,1          ; 将1加载到AL寄存器
    mov number,al     ; 将AL寄存器的值（1）存储到number变量
    mov al,goods_num1 ; 将goods_num1的值加载到AL寄存器
    cmp al,0          ; 比较AL寄存器中的值是否为0（判断商品1是否缺货）
    je show_nothing   ; 如果商品1缺货，则跳转到show_nothing，显示无货信息
    jmp take_away     ; 如果商品1有货，则跳转到take_away，进行取货操作

; 判断按下的键是不是2
is_2:
    cmp al,32h        ; 比较AL寄存器中的值是否为ASCII码‘2’（32h）
    jne is_3          ; 如果不是‘2’，则跳转到is_3，继续判断是不是3
    mov al,2          ; 将2加载到AL寄存器
    mov number,al     ; 将AL寄存器的值（2）存储到number变量
    mov al,goods_num2 ; 将goods_num2的值加载到AL寄存器
    cmp al,0          ; 比较AL寄存器中的值是否为0（判断商品2是否缺货）
    je show_nothing   ; 如果商品2缺货，则跳转到show_nothing，显示无货信息
    jmp take_away     ; 如果商品2有货，则跳转到take_away，进行取货操作

; 判断按下的键是不是3
is_3:
    cmp al,33h        ; 比较AL寄存器中的值是否为ASCII码‘3’（33h）
    jne is_4          ; 如果不是‘3’，则跳转到is_4，继续判断是不是4
    mov al,3          ; 将3加载到AL寄存器
    mov number,al     ; 将AL寄存器的值（3）存储到number变量
    mov al,goods_num3 ; 将goods_num3的值加载到AL寄存器
    cmp al,0          ; 比较AL寄存器中的值是否为0（判断商品3是否缺货）
    je show_nothing   ; 如果商品3缺货，则跳转到show_nothing，显示无货信息
    jmp take_away     ; 如果商品3有货，则跳转到take_away，进行取货操作

; 判断按下的键是不是4
is_4:
    cmp al,34h        ; 比较AL寄存器中的值是否为ASCII码‘4’（34h）
    jne choosing      ; 如果不是‘4’，则跳转到choosing，继续等待用户选择
    mov al,4          ; 将4加载到AL寄存器
    mov number,al     ; 将AL寄存器的值（4）存储到number变量
    mov al,goods_num4 ; 将goods_num4的值加载到AL寄存器
    cmp al,0          ; 比较AL寄存器中的值是否为0（判断商品4是否缺货）
    je show_nothing   ; 如果商品4缺货，则跳转到show_nothing，显示无货信息
    jmp take_away     ; 如果商品4有货，则跳转到take_away，进行取货操作

show_nothing:
    call SHOW_LCD_CLEAR ;  有请求，清空LCD屏幕    
    call SHOW_out_of_stock
                 mov cx,05fh
dll_out_of_stock:call DELAY1
                 loop dll_out_of_stock
    
    jmp do_again
;限时货物选择部分结束

; 货物出货提醒部分开始。	
;这段代码实现了货物出货提醒的功能。它通过停止计数器计数、调用声光提示系统、清空LCD屏幕并显示取货提示信息，以及延时操作，来提示用户取货。计数器的配置和初值的设置确保了计数器能够正确地停止和复位，延时操作则保证了提示信息能在屏幕上停留足够长的时间，让用户能够清楚地看到提示信息。
take_away:

    ; 8254停止计数;至少要来一个脉冲清零，初值不能为零
    ;停止计数器2的计数
    mov dx, 283h          ; 设置DX为8254计数器控制端口地址
    mov al, 10010100b     ; 设置计数器2，模式2，二进制计数
    out dx, al            ; 将AL寄存器的值输出到DX指定的端口
    mov dx, 282h          ; 设置DX为计数器2的数据端口地址
    mov al, 1             ; 设定计数初值为1
    out dx, al            ; 将AL寄存器的值输出到DX指定的端口
    ;停止计数器0的计数
    mov dx, 283h          ; 设置DX为计数器控制端口地址
    mov al, 00010000b     ; 设置计数器0，模式0，二进制计数
    out dx, al            ; 将AL寄存器的值输出到DX指定的端口
    mov dx, 280h          ; 设置DX为计数器0的数据端口地址
    mov al, 1             ; 设定计数初值为1
    out dx, al            ; 将AL寄存器的值输出到DX指定的端口

    call SOUND_LIGHT      ; 调用声光提示系统子程序

    call SHOW_LCD_CLEAR   ; 清空LCD屏幕
    call SHOW_TAKE_GOODS  ; 显示取货提示信息

    mov cx, 05fh          ; 将0x5F（95）加载到CX寄存器，用于延时循环计数
dll_TAKE_GOODS:
    call DELAY1           ; 调用延时子程序DELAY1
    loop dll_TAKE_GOODS   ; 循环执行，直到CX减为0，进行95次延时

   
; 键盘 enter 代表货物被取走
take_away1:
    mov ah,08h           ; 设置功能代码 08h，用于等待键盘输入
    int 21h              ; 调用 BIOS 中断 21h 获取键盘输入
    cmp al,0dh           ; 比较 AL 寄存器中的值是否为 ASCII 码 'Enter' (0Dh)
    jne take_away1       ; 如果不是 'Enter' 键，跳转回 take_away1 继续等待输入

    mov al,number        ; 将 number 变量的值加载到 AL 寄存器
    cmp al,1             ; 比较 AL 寄存器的值是否为 1
    je dec_1             ; 如果 AL 等于 1，跳转到 dec_1
    cmp al,2             ; 比较 AL 寄存器的值是否为 2
    je dec_2             ; 如果 AL 等于 2，跳转到 dec_2
    cmp al,3             ; 比较 AL 寄存器的值是否为 3
    je dec_3             ; 如果 AL 等于 3，跳转到 dec_3
    jmp dec_4            ; 否则，跳转到 dec_4

; 减少商品1的数量
dec_1:
    mov al,goods_num1    ; 将 goods_num1 的值加载到 AL 寄存器
    dec al               ; 减少 AL 寄存器的值
    mov goods_num1,al    ; 将 AL 的值存回 goods_num1
    jmp finished         ; 跳转到 finished

; 减少商品2的数量
dec_2:
    mov al,goods_num2    ; 将 goods_num2 的值加载到 AL 寄存器
    dec al               ; 减少 AL 寄存器的值
    mov goods_num2,al    ; 将 AL 的值存回 goods_num2
    jmp finished         ; 跳转到 finished

; 减少商品3的数量
dec_3:
    mov al,goods_num3    ; 将 goods_num3 的值加载到 AL 寄存器
    dec al               ; 减少 AL 寄存器的值
    mov goods_num3,al    ; 将 AL 的值存回 goods_num3
    jmp finished         ; 跳转到 finished

; 减少商品4的数量
dec_4:
    mov al,goods_num4    ; 将 goods_num4 的值加载到 AL 寄存器
    dec al               ; 减少 AL 寄存器的值
    mov goods_num4,al    ; 将 AL 的值存回 goods_num4

; 货物被取走，停止报警和闪光
finished:
    call STOP_SOUND_LIGHT ; 调用子程序停止声光提示

    call SHOW_LCD_CLEAR   ; 调用子程序清空 LCD 屏幕
    call SHOW_TAKE_GOODS_success ; 调用子程序显示取货成功提示

    mov cx,05fh           ; 将 0x5F (95) 加载到 CX 寄存器，用于延时循环计数
dll:
    call DELAY1           ; 调用延时子程序 DELAY1
    loop dll              ; 循环执行，直到 CX 减为 0，进行 95 次延时




;检测库存是否紧缺（当有货物库存为0时定义为"紧缺"）
    mov al,goods_num1
    cmp al,0
    je supplement
    mov al,goods_num2
    cmp al,0
    je supplement
    mov al,goods_num3
    cmp al,0
    je supplement
    mov al,goods_num4
    cmp al,0
    je supplement
    
;完成购买，返回等待状态
    jmp do_again   

;如果紧缺，则低频报警；但是并不会影响正常其他产品的购买
supplement:
    call LOW_ALARM
    jmp do_again


; LCD提示用户键入1开始购买
SHOW_GUIDANCE proc near
          PUSH AX               ; 保存AX寄存器的值
          PUSH DS               ; 保存DS寄存器的值
          PUSH DX               ; 保存DX寄存器的值
          PUSH BX               ; 保存BX寄存器的值
          PUSH CX               ; 保存CX寄存器的值

          CALL LCD_CLEAR        ; 调用LCD清屏子程序
          LEA BX, HZ_GUID       ; 将提示信息的地址加载到BX寄存器
          MOV CH, 2             ; 设置CH为2，表示显示第2行信息
          CALL LCD_GUIDANCE_DISP ; 调用子程序，在LCD显示第2行提示信息
          LEA BX, HZ_GUID       ; 将提示信息的地址加载到BX寄存器
          MOV CH, 3             ; 设置CH为3，表示显示第3行信息
          CALL LCD_GUIDANCE_DISP ; 调用子程序，在LCD显示第3行提示信息

          POP CX                ; 恢复CX寄存器的值
          POP BX                ; 恢复BX寄存器的值
          POP DX                ; 恢复DX寄存器的值
          POP DS                ; 恢复DS寄存器的值
          POP AX                ; 恢复AX寄存器的值
          RET                   ; 返回调用处
SHOW_GUIDANCE endp


LCD_GUIDANCE_DISP PROC NEAR
            LEA BX, HZ_GUID       ; 将提示信息的地址加载到BX寄存器
            CMP CH, 2             ; 比较CH寄存器的值是否为2
            JZ DISP_GUIDANCE_SEC  ; 如果CH等于2，跳转到DISP_GUIDANCE_SEC标签
            MOV BYTE PTR HZ_GUID_ADR, 88H ; 将第三行起始端口地址88H加载到HZ_GUID_ADR
            ADD BX, 16            ; 将BX寄存器的值加16，指向第二行信息
            JMP next_GUIDANCE     ; 跳转到next_GUIDANCE标签
DISP_GUIDANCE_SEC:
            MOV BYTE PTR HZ_GUID_ADR, 90H ; 将第三行起始端口地址90H加载到HZ_GUID_ADR
next_GUIDANCE:
            MOV CL, 8             ; 将8加载到CL寄存器，表示要显示的字符数
CONTINUE_GUIDANCE:
            PUSH CX               ; 保存CX寄存器的值
            MOV AL, HZ_GUID_ADR   ; 将HZ_GUID_ADR的值加载到AL寄存器
            MOV DX, PORTA         ; 将8255A端口地址加载到DX寄存器
            OUT DX, AL            ; 将AL寄存器的值输出到DX指定的端口
            CALL CMD_SETUP        ; 调用子程序CMD_SETUP，设定DDRAM地址命令
            MOV AX, [BX]          ; 将BX寄存器指向的地址的内容加载到AX寄存器
            PUSH AX               ; 保存AX寄存器的值
            MOV AL, AH            ; 将AX寄存器的高字节加载到AL寄存器
            MOV DX, PORTA         ; 将8255A端口地址加载到DX寄存器
            OUT DX, AL            ; 将AL寄存器的值输出到DX指定的端口
            CALL DATA_SETUP       ; 调用子程序DATA_SETUP，输出汉字编码高字节
            CALL DELAY            ; 调用子程序DELAY，进行延迟
            POP AX                ; 恢复AX寄存器的值
            MOV DX, PORTA         ; 将8255A端口地址加载到DX寄存器
            OUT DX, AL            ; 将AL寄存器的值输出到DX指定的端口
            CALL DATA_SETUP       ; 调用子程序DATA_SETUP，输出汉字编码低字节
            CALL DELAY            ; 调用子程序DELAY，进行延迟
            INC BX                ; BX寄存器加1
            INC BX                ; BX寄存器再加1，指向下一个字符
            INC BYTE PTR HZ_GUID_ADR ; 将HZ_GUID_ADR的值加1，修改LCD显示端口地址
            POP CX                ; 恢复CX寄存器的值
            DEC CL                ; 将CL寄存器的值减1
            JNZ CONTINUE_GUIDANCE ; 如果CL不为零，跳转到CONTINUE_GUIDANCE标签，继续循环
            RET                   ; 返回调用处
LCD_GUIDANCE_DISP ENDP


; 清空LCD屏幕
SHOW_LCD_CLEAR proc near
    PUSH AX       ; 保存AX寄存器的值
    PUSH DS       ; 保存DS寄存器的值
    PUSH DX       ; 保存DX寄存器的值
    PUSH BX       ; 保存BX寄存器的值
    PUSH CX       ; 保存CX寄存器的值

    CALL LCD_CLEAR ; 调用LCD清屏函数
    LEA BX, HZ_CLEAR ; 加载清屏字符地址到BX寄存器
    MOV CH, 2     ; 设置CH寄存器为2，显示第2行信息
    CALL LCD_CLEAR_DISP ; 调用LCD清屏显示函数
    LEA BX, HZ_CLEAR ; 加载清屏字符地址到BX寄存器
    MOV CH, 3     ; 设置CH寄存器为3，显示第3行信息
    CALL LCD_CLEAR_DISP ; 调用LCD清屏显示函数

    POP CX        ; 恢复CX寄存器的值
    POP BX        ; 恢复BX寄存器的值
    POP DX        ; 恢复DX寄存器的值
    POP DS        ; 恢复DS寄存器的值
    POP AX        ; 恢复AX寄存器的值
    RET           ; 返回调用处
SHOW_LCD_CLEAR ENDP

LCD_CLEAR_DISP PROC NEAR
            LEA BX, HZ_CLEAR
            CMP CH, 2
           	JZ  DISP_CLEAR_SEC
            MOV BYTE PTR HZ_CLEAR_ADR, 88H        ;第三行起始端口地址
            ADD BX,16                        ;指向第二行信息
            JMP  next_CLEAR
DISP_CLEAR_SEC:   MOV BYTE PTR HZ_CLEAR_ADR,90H
next_CLEAR:           mov cl,8
CONTINUE_CLEAR:   
            push cx
            MOV AL,HZ_CLEAR_ADR
            MOV DX, PORTA
            OUT DX, AL
            CALL CMD_SETUP          ;设定DDRAM地址命令
            MOV AX,[BX]
            PUSH AX
            MOV AL,AH               ;先送汉字编码高位
            MOV DX,PORTA
            OUT DX,AL
            CALL DATA_SETUP         ;输出汉字编码高字节
            CALL DELAY              ;延迟
            POP AX
            MOV DX,PORTA
            OUT DX, AL
            CALL DATA_SETUP         ;输出汉字编码低字节
            CALL DELAY
            INC BX
            INC BX                  ;修改显示内码缓冲区指针
            INC BYTE PTR HZ_CLEAR_ADR     ;修改LCD显示端口地址
            POP CX
            DEC CL
            JNZ  CONTINUE_CLEAR
            RET
LCD_CLEAR_DISP   ENDP

; 清空LCD屏幕主体
LCD_CLEAR proc near
    MOV AX, DATA      ; 将数据段地址加载到AX寄存器
    MOV DS, AX        ; 将AX寄存器的值移动到DS寄存器，设置数据段
    MOV DX, PORTA     ; 将8255A端口地址加载到DX寄存器
    ADD DX, 3         ; 将DX寄存器的值增加3，指向控制端口
    MOV AL, 80H       ; 将80H（DDRAM清屏命令）加载到AL寄存器
    OUT DX, AL        ; 将AL寄存器的值输出到DX寄存器指定的端口，初始化8255
    MOV AL, 0FFH      ; 将0FFH加载到AL寄存器，用于清空LCD
    MOV DX, PORTA     ; 将8255A端口地址加载到DX寄存器
    OUT DX, AL        ; 将AL寄存器的值输出到DX寄存器指定的端口，清空LCD
    MOV AL, 0CH       ; 将0CH（LCD清屏命令）加载到AL寄存器
    MOV DX, PORTA     ; 将8255A端口地址加载到DX寄存器
    OUT DX, AL        ; 将AL寄存器的值输出到DX寄存器指定的端口，设置CLEAR命令
    CALL CMD_SETUP    ; 调用CMD_SETUP过程，启动LCD执行命令
    RET               ; 返回调用处
LCD_CLEAR endp


CMD_SETUP PROC NEAR
           MOV DX, PORTA                ; 指向 8255 端口控制端口
           ADD DX, 2                    ; 移动到控制端口
           NOP                          ; 无操作，延时
           MOV AL, 00000000B            ; PC1 置 0, PC0 置 0 （LCD I 端 = 0，W 端 = 0）
           OUT DX, AL                   ; 将 AL 寄存器的值输出到 DX 指定的端口
           CALL delay                   ; 调用延时子程序
           NOP                          ; 无操作，延时
           MOV AL, 00000100B            ; PC2 置 1 （LCD E 端 = 1）
           OUT DX, AL                   ; 将 AL 寄存器的值输出到 DX 指定的端口
           NOP                          ; 无操作，延时
           CALL delay                   ; 调用延时子程序
           MOV AL, 00000000B            ; PC2 置 0,（LCD E 端置 0）
           OUT DX, AL                   ; 将 AL 寄存器的值输出到 DX 指定的端口
           CALL delay                   ; 调用延时子程序

           RET                          ; 返回调用处
CMD_SETUP ENDP


DATA_SETUP      PROC
            MOV DX,PORTA                ;指向8255控制端口
            ADD DX,2
            MOV AL,00000001B                ;PC1置0，PC0=1 （LCD I端=1）
            OUT DX, AL
            NOP
            call delay
            MOV AL,00000101B                ;PC2置1 （LCD E端＝1）
            OUT DX, AL
            NOP
            call delay
            MOV AL, 00000001B               ;PC2置0,（LCD E端＝0）
            OUT DX, AL
            NOP
            call delay
            RET
DATA_SETUP      ENDP

DELAY  PROC NEAR
           push cx
           push dx
           MOV CX, 0fffh 
 x1:      loop   x1
           pop dx
           pop cx
           RET
DELAY  ENDP

DELAY1  PROC NEAR
           push cx
           push bx
           MOV CX, 0ffffh 
 loop1:    MOV BX,0ffffh
 loop2:    dec bx
           cmp bx,0
           je loop2
           loop loop1
           pop bx
           pop cx
           RET
DELAY1  ENDP

;LCD显示商品信息;LCD显示货物编号及库存，供用户进行选择，您有五分钟的选择时间
SHOW_GOODS proc near
          PUSH AX
          PUSH DS
          PUSH DX
          PUSH BX
          PUSH CX

          CALL LCD_CLEAR
          LEA BX,  HZ_GOODS
          MOV CH,2                        ;显示第2行信息 
          CALL LCD_GOODS_DISP
          LEA BX, HZ_GOODS
          MOV CH,3                  ;    显示第3行信息
          CALL LCD_GOODS_DISP

          POP CX
          POP BX
          POP DX
          POP DS
          POP AX
          RET
SHOW_GOODS endp

LCD_GOODS_DISP PROC NEAR
            LEA BX, HZ_GOODS
            CMP CH, 2
            JZ  DISP_GOODS_SEC
            MOV BYTE PTR HZ_GOODS_ADR, 88H        ;第三行起始端口地址
            ADD BX,16                        ;指向第二行信息
            JMP  next_GOODS
DISP_GOODS_SEC:   MOV BYTE PTR HZ_GOODS_ADR,90H
next_GOODS:           mov cl,8
CONTINUE_GOODS:   
            push cx
            MOV AL,HZ_GOODS_ADR
            MOV DX, PORTA
            OUT DX, AL
            CALL CMD_SETUP          ;设定DDRAM地址命令
            MOV AX,[BX]
            PUSH AX
            MOV AL,AH               ;先送汉字编码高位
            MOV DX,PORTA
            OUT DX,AL
            CALL DATA_SETUP         ;输出汉字编码高字节
            CALL DELAY              ;延迟
            POP AX
            MOV DX,PORTA
            OUT DX, AL
            CALL DATA_SETUP         ;输出汉字编码低字节
            CALL DELAY
            INC BX
            INC BX                  ;修改显示内码缓冲区指针
            INC BYTE PTR HZ_GOODS_ADR     ;修改LCD显示端口地址
            POP CX
            DEC CL
            JNZ  CONTINUE_GOODS
            RET
LCD_GOODS_DISP   ENDP

; LCD提示该商品售罄
SHOW_out_of_stock proc near
          PUSH AX      ; 保存AX寄存器的值
          PUSH DS      ; 保存DS寄存器的值
          PUSH DX      ; 保存DX寄存器的值
          PUSH BX      ; 保存BX寄存器的值
          PUSH CX      ; 保存CX寄存器的值

          CALL LCD_CLEAR         ; 调用LCD清屏子程序
          LEA BX, HZ_OUT         ; 将售罄提示信息“地址”加载到BX寄存器（而非内容）
          MOV CH, 2              ; 设置CH为2，显示第2行信息 
          CALL LCD_out_of_stock_DISP ; 调用子程序，在LCD显示第2行售罄信息
          LEA BX, HZ_OUT         ; 将售罄提示信息地址加载到BX寄存器
          MOV CH, 3              ; 设置CH为3，显示第3行信息
          CALL LCD_out_of_stock_DISP ; 调用子程序，在LCD显示第3行售罄信息
          call DELAY1            ; 调用延时子程序DELAY1

          POP CX      ; 恢复CX寄存器的值
          POP BX      ; 恢复BX寄存器的值
          POP DX      ; 恢复DX寄存器的值
          POP DS      ; 恢复DS寄存器的值
          POP AX      ; 恢复AX寄存器的值
          RET         ; 返回调用处
SHOW_out_of_stock endp


LCD_out_of_stock_DISP PROC NEAR
            LEA BX, HZ_OUT                   ; 将售罄提示信息的地址加载到BX寄存器
            CMP CH, 2                        ; 比较CH寄存器的值是否为2
            JZ DISP_out_of_stock_SEC         ; 如果CH等于2，跳转到DISP_out_of_stock_SEC标签
            MOV BYTE PTR HZ_OUT_ADR, 88H     ; 将第三行起始端口地址88H加载到HZ_OUT_ADR
            ADD BX, 16                       ; 将BX寄存器的值加16，指向第二行信息
            JMP next_out_of_stock            ; 跳转到next_out_of_stock标签
DISP_out_of_stock_SEC:   
            MOV BYTE PTR HZ_OUT_ADR, 90H     ; 将第三行起始端口地址90H加载到HZ_OUT_ADR
next_out_of_stock:   
            MOV CL, 8                        ; 将8加载到CL寄存器，表示要显示的字符数
CONTINUE_out_of_stock:   
            PUSH CX                          ; 保存CX寄存器的值
            MOV AL, HZ_OUT_ADR               ; 将HZ_OUT_ADR的值加载到AL寄存器
            MOV DX, PORTA                    ; 将8255A端口地址加载到DX寄存器
            OUT DX, AL                       ; 将AL寄存器的值输出到DX指定的端口
            CALL CMD_SETUP                   ; 调用子程序CMD_SETUP，设定DDRAM地址命令
            MOV AX, [BX]                     ; 将BX寄存器指向的地址的内容加载到AX寄存器
            PUSH AX                          ; 保存AX寄存器的值
            MOV AL, AH                       ; 将AX寄存器的高字节加载到AL寄存器
            MOV DX, PORTA                    ; 将8255A端口地址加载到DX寄存器
            OUT DX, AL                       ; 将AL寄存器的值输出到DX指定的端口
            CALL DATA_SETUP                  ; 调用子程序DATA_SETUP，输出汉字编码高字节
            CALL DELAY                       ; 调用子程序DELAY，进行延迟
            POP AX                           ; 恢复AX寄存器的值
            MOV DX, PORTA                    ; 将8255A端口地址加载到DX寄存器
            OUT DX, AL                       ; 将AL寄存器的值输出到DX指定的端口
            CALL DATA_SETUP                  ; 调用子程序DATA_SETUP，输出汉字编码低字节
            CALL DELAY                       ; 调用子程序DELAY，进行延迟
            INC BX                           ; BX寄存器加1
            INC BX                           ; BX寄存器再加1，指向下一个字符
            INC BYTE PTR HZ_OUT_ADR          ; 将HZ_OUT_ADR的值加1，修改LCD显示端口地址
            POP CX                           ; 恢复CX寄存器的值
            DEC CL                           ; 将CL寄存器的值减1
            JNZ CONTINUE_out_of_stock        ; 如果CL不为零，跳转到CONTINUE_out_of_stock标签，继续循环
            RET                              ; 返回调用处
LCD_out_of_stock_DISP ENDP


;提示拿走商品
SHOW_TAKE_GOODS proc near
          PUSH AX
          PUSH DS
          PUSH DX
          PUSH BX
          PUSH CX

          CALL LCD_CLEAR
          LEA BX,  HZ_TAKE
          MOV CH,2                        ;显示第2行信息 
          CALL  LCD_TAKE_DISP
          LEA BX, HZ_TAKE
          MOV CH,3                  ;    显示第3行信息
          CALL  LCD_TAKE_DISP
          call DELAY1
          
          POP CX
          POP BX
          POP DX
          POP DS
          POP AX
          RET
SHOW_TAKE_GOODS endp

LCD_TAKE_DISP PROC NEAR
            LEA BX, HZ_TAKE
            CMP CH, 2
            JZ  DISP_TAKE_SEC
            MOV BYTE PTR HZ_TAKE_ADR, 88H        ;第三行起始端口地址
            ADD BX,16                        ;指向第二行信息
            JMP  next_TAKE
DISP_TAKE_SEC:   MOV BYTE PTR HZ_TAKE_ADR,90H
next_TAKE:           mov cl,8
CONTINUE_TAKE:   
            push cx
            MOV AL,HZ_TAKE_ADR
            MOV DX, PORTA
            OUT DX, AL
            CALL CMD_SETUP          ;设定DDRAM地址命令
            MOV AX,[BX]
            PUSH AX
            MOV AL,AH               ;先送汉字编码高位
            MOV DX,PORTA
            OUT DX,AL
            CALL DATA_SETUP         ;输出汉字编码高字节
            CALL DELAY              ;延迟
            POP AX
            MOV DX,PORTA
            OUT DX, AL
            CALL DATA_SETUP         ;输出汉字编码低字节
            CALL DELAY
            INC BX
            INC BX                  ;修改显示内码缓冲区指针
            INC BYTE PTR HZ_TAKE_ADR     ;修改LCD显示端口地址
            POP CX
            DEC CL
            JNZ  CONTINUE_TAKE
            RET
LCD_TAKE_DISP   ENDP

;提示拿走商品
SHOW_TAKE_GOODS_success proc near
          PUSH AX
          PUSH DS
          PUSH DX
          PUSH BX
          PUSH CX

          CALL LCD_CLEAR
          LEA BX,  HZ_TAKE_success
          MOV CH,2                        ;显示第2行信息 
          CALL  LCD_TAKE_success_DISP
          LEA BX, HZ_TAKE
          MOV CH,3                  ;    显示第3行信息
          CALL  LCD_TAKE_success_DISP
          call DELAY1
          
          POP CX
          POP BX
          POP DX
          POP DS
          POP AX
          RET
SHOW_TAKE_GOODS_success endp

LCD_TAKE_success_DISP PROC NEAR
            LEA BX, HZ_TAKE_success
            CMP CH, 2
            JZ  DISP_TAKE_success_SEC
            MOV BYTE PTR HZ_TAKE_success_ADR, 88H        ;第三行起始端口地址
            ADD BX,16                        ;指向第二行信息
            JMP  next_TAKE_success
DISP_TAKE_success_SEC:   MOV BYTE PTR HZ_TAKE_success_ADR,90H
next_TAKE_success:           mov cl,8
CONTINUE_TAKE_success:   
            push cx
            MOV AL,HZ_TAKE_success_ADR
            MOV DX, PORTA
            OUT DX, AL
            CALL CMD_SETUP          ;设定DDRAM地址命令
            MOV AX,[BX]
            PUSH AX
            MOV AL,AH               ;先送汉字编码高位
            MOV DX,PORTA
            OUT DX,AL
            CALL DATA_SETUP         ;输出汉字编码高字节
            CALL DELAY              ;延迟
            POP AX
            MOV DX,PORTA
            OUT DX, AL
            CALL DATA_SETUP         ;输出汉字编码低字节
            CALL DELAY
            INC BX
            INC BX                  ;修改显示内码缓冲区指针
            INC BYTE PTR HZ_TAKE_success_ADR     ;修改LCD显示端口地址
            POP CX
            DEC CL
            JNZ  CONTINUE_TAKE_success
            RET
LCD_TAKE_success_DISP   ENDP

;LCD补货提示
SHOW_RECOVER proc near
          PUSH AX
          PUSH DS
          PUSH DX
          PUSH BX
          PUSH CX

          CALL LCD_CLEAR
          LEA BX,  HZ_REC
          MOV CH,2                        ;显示第2行信息 
          CALL  LCD_RECOVER_DISP
          LEA BX, HZ_GUID
          MOV CH,3                  ;    显示第3行信息
          CALL LCD_RECOVER_DISP

          POP CX
          POP BX
          POP DX
          POP DS
          POP AX
          RET
SHOW_RECOVER endp

LCD_RECOVER_DISP PROC NEAR
            LEA BX, HZ_REC
            CMP CH, 2
           JZ  DISP_RECOVER_SEC
            MOV BYTE PTR HZ_REC_ADR, 88H        ;第三行起始端口地址
            ADD BX,16                        ;指向第二行信息
            JMP  next_RECOVER
DISP_RECOVER_SEC:   MOV BYTE PTR HZ_REC_ADR,90H
next_RECOVER:           mov cl,8
CONTINUE_RECOVER:   
            push cx
            MOV AL,HZ_REC_ADR
            MOV DX, PORTA
            OUT DX, AL
            CALL CMD_SETUP          ;设定DDRAM地址命令
            MOV AX,[BX]
            PUSH AX
            MOV AL,AH               ;先送汉字编码高位
            MOV DX,PORTA
            OUT DX,AL
            CALL DATA_SETUP         ;输出汉字编码高字节
            CALL DELAY              ;延迟
            POP AX
            MOV DX,PORTA
            OUT DX, AL
            CALL DATA_SETUP         ;输出汉字编码低字节
            CALL DELAY
            INC BX
            INC BX                  ;修改显示内码缓冲区指针
            INC BYTE PTR HZ_REC_ADR     ;修改LCD显示端口地址
            POP CX
            DEC CL
            JNZ  CONTINUE_RECOVER
            RET
LCD_RECOVER_DISP   ENDP

;8254控制灯泡闪烁，蜂鸣器高频声音
SOUND_LIGHT proc near
    push dx
    push ax
    ;蜂鸣器和小灯泡闪烁频率相同，使用方式2(分频器)和方式3(方波发生器)，0.5s
    ;out1连接小灯泡和蜂鸣器
    mov dx,283h
    mov al,00110100b	;计数器0，方式2
    out dx,al 
    mov dx,280h
    mov ax,1000
    out dx,al
    mov al,ah
    out dx,al

    mov dx,283h
    mov al,01110110b	;计数器1，方式3
    out dx,al
    mov ax,500
    mov dx,281h
    out dx,al
    mov al,ah
    out dx,al
    pop ax
    pop dx
    ret
SOUND_LIGHT endp


;停止灯泡闪烁以及高频声音
STOP_SOUND_LIGHT proc near
    push dx
    push ax
    mov dx,283h
    mov al,00010100b
    out dx,al
    mov dx,280h
    mov ax,1
    out dx,al

    mov dx,283h
    mov al,01010110b
    out dx,al
    mov ax,1
    mov dx,281h
    out dx,al
    pop ax
    pop dx
    ret
STOP_SOUND_LIGHT endp

INT1 proc near
push ax           ; 保存AX寄存器的当前值
push ds           ; 保存DS寄存器的当前值
push dx           ; 保存DX寄存器的当前值
push bx           ; 保存BX寄存器的当前值
push cx           ; 保存CX寄存器的当前值
mov cx, 1         ; 将CX寄存器置为1

mov dx, 28bh      ; 将DX寄存器置为8255端口地址
mov al, 10000000b ; 将AL寄存器置为10000000b，初始化8255
out dx, al        ; 将AL的值输出到DX指定的端口（28bh）

mov ax, 350bh     ; 准备调用INT 21h，功能号为0bh（获取中断向量）
int 21h           ; 通过DOS中断21h获取中断向量，结果存入ES:BX
mov int_off, bx   ; 保存BX中的中断偏移地址到变量int_off
mov bx, es        ; 将ES寄存器的值移到BX
mov int_seg, bx   ; 保存BX中的中断段地址到变量int_seg

cli               ; 禁用中断，确保在设置新的中断向量时不会被打断

mov dx, seg REPLENISH ; 将DX置为REPLENISH段地址
mov ds, dx        ; 将DS寄存器置为REPLENISH段地址
mov dx, offset REPLENISH ; 将DX置为REPLENISH的偏移地址
mov ax, 250bh     ; 准备调用INT 21h，功能号为250bh（设置中断向量）
int 21h           ; 通过DOS中断21h设置新的中断向量

in al, 21h        ; 从端口21h读取当前中断屏蔽字到AL
and al, 11110111b ; 清除AL中的第3位，将该位设为0，打开相应中断
out 21h, al       ; 将修改后的屏蔽字写回端口21h

sti               ; 启用中断
tttt:             ; 标签，用于循环
    mov dx, 28bh      ; 将DX置为8255端口地址
    mov al, 00001010b ; 将AL置为00001010b，使PC6输出低电平
    out dx, al        ; 将AL的值输出到DX指定的端口（28bh）
    nop               ; 空操作，提供延时
    nop               ; 空操作，提供延时
    mov al, 00001011b ; 将AL置为00001011b，使PC6输出高电平
    out dx, al        ; 将AL的值输出到DX指定的端口（28bh）
    nop               ; 空操作，提供延时
    nop               ; 空操作，提供延时

    ;cmp cx, 0         ; 比较CX与0
    ;jne tttt         ; 如果CX不为0，则跳转到tttt标签处（注释掉了）

cli               ; 禁用中断
mov dx, word ptr int_off ; 将DX置为保存的原中断偏移地址
mov ds, word ptr int_seg ; 将DS置为保存的原中断段地址
mov ax, 250bh     ; 准备调用INT 21h，功能号为250bh（设置中断向量）
int 21h           ; 通过DOS中断21h恢复原来的中断向量

in al, 21h        ; 从端口21h读取当前中断屏蔽字到AL
or al, 00001000b  ; 设置AL中的第3位，将该位设为1，关闭相应中断
out 21h, al       ; 将修改后的屏蔽字写回端口21h


call STOP_LOW_ALARM;货物补充完毕停止低频报警
pop cx
pop bx
pop dx
pop ds
pop ax
ret
INT1 endp


;补货中断程序
REPLENISH proc far     
sti
push dx
push ax
    
dec cx   
wait2:
mov ah,0bh
int 21h
cmp al,0h
je wait2;   无键按下，继续等待


;mov al,5
;mov goods_num1,al;
;mov goods_num2,al;
;mov goods_num3,al;
;mov goods_num4,al;

cli
mov ax,data
mov ds,ax
mov al,20h    ;关中断
out 20h,al
pop ax
pop dx
iret 
REPLENISH endp


; 蜂鸣器低频报警
LOW_ALARM proc near
    push dx             ; 保存DX寄存器的值
    push ax             ; 保存AX寄存器的值

    ; 使用方式3(方波发生器)和方式2(分频器)，2秒间隔
    ; out1连接蜂鸣器

    mov dx,283h         ; 设置DX为8253计数器控制端口地址
    mov al,00110100b    ; 设置计数器0，方式3，二进制计数
    out dx,al           ; 将AL寄存器的值输出到DX指定的端口
    mov dx,280h         ; 设置DX为计数器0的数据端口地址
    mov ax,10000        ; 设定计数初值为10000
    out dx,al           ; 将AX寄存器的低8位输出到DX指定的端口
    mov al,ah           ; 获取AX寄存器的高8位
    out dx,al           ; 将AX寄存器的高8位输出到DX指定的端口

    mov dx,283h         ; 设置DX为8253计数器控制端口地址
    mov al,01110110b    ; 设置计数器1，方式2，二进制计数
    out dx,al           ; 将AL寄存器的值输出到DX指定的端口
    mov ax,200          ; 设定计数初值为200
    mov dx,281h         ; 设置DX为计数器1的数据端口地址
    out dx,al           ; 将AX寄存器的低8位输出到DX指定的端口
    mov al,ah           ; 获取AX寄存器的高8位
    out dx,al           ; 将AX寄存器的高8位输出到DX指定的端口

    pop ax              ; 恢复AX寄存器的值
    pop dx              ; 恢复DX寄存器的值
    ret                 ; 返回调用处
LOW_ALARM endp


STOP_LOW_ALARM proc near
    push dx             ; 保存DX寄存器的值
    push ax             ; 保存AX寄存器的值

    mov dx,283h         ; 设置DX为8253计数器控制端口地址
    mov al,00010100b    ; 设置计数器0，方式0，二进制计数
    out dx,al           ; 将AL寄存器的值输出到DX指定的端口
    mov dx,280h         ; 设置DX为计数器0的数据端口地址
    mov ax,1            ; 设定计数初值为1
    out dx,al           ; 将AX寄存器的低8位输出到DX指定的端口

    mov dx,283h         ; 设置DX为8253计数器控制端口地址
    mov al,01010110b    ; 设置计数器1，方式0，二进制计数
    out dx,al           ; 将AL寄存器的值输出到DX指定的端口
    mov ax,1            ; 设定计数初值为1
    mov dx,281h         ; 设置DX为计数器1的数据端口地址
    out dx,al           ; 将AX寄存器的低8位输出到DX指定的端口

    pop ax              ; 恢复AX寄存器的值
    pop dx              ; 恢复DX寄存器的值
    ret                 ; 返回调用处
STOP_LOW_ALARM endp

code ends
end start
```

