<img src="D:\学习\交大高清标示--透明背景（校徽等）\交大高清标示--透明背景-03.png" style="zoom:33%;" />


<h1 align = "center" style="font-size:40px">北京交通大学</h1>

<center style="font-size:18px">		课程名称：嵌入式系统设计</left>
<center style="font-size:18px">实验题目     ：ARM汇编程序设计</center>
<center style="font-size:18px">学号    ：22281188</center>
<center style="font-size:18px">姓名 ： 江家玮</center>
<center style="font-size:18px">班级 ： 计科2204班</center>
<center style="font-size:18px">指导老师 ： 唐宏老师</center>
<center style="font-size:18px">报告日期 ：2024-10-18</center>


------

<h1 align = "center" style="font-size:30px">目录</h2>

[TOC]



 <div style="page-break-after: always;"></div>

## 实验3-1汇编程序调用C语言实验

### （1）在实验参考程序中，Startup.s文件的作用是什么? 试分析其中的代码功能。

`Startup.s` 文件的主要作用是**初始化系统**的运行环境，为C程序的执行做准备。该文件设置了堆栈指针，初始化了内存区域，之后跳转到C程序的 `main` 函数，开始实际的应用程序执行。

1. **导入符号**：
   ```assembly
   IMPORT |Image$$RO$$Limit|
   IMPORT |Image$$RW$$Base|
   IMPORT |Image$$ZI$$Base|
   IMPORT |Image$$ZI$$Limit|
   IMPORT MAIN
   ```
   这些指令用于从链接文件中导入相关的地址和符号，包括只读段、读写段、未初始化数据段的基地址和限制地址。`MAIN` 是在C程序中定义的 `main()` 函数，这里需要跳转到它。

2. **代码段设置与入口**：
   ```assembly
   AREA start,CODE,READONLY
   ENTRY
   CODE32	;这是32位代码
   ```
   定义了代码段，指定它为只读并声明它是程序的入口点。

3. **设置堆栈指针**：
   ```assembly
   Reset
   LDR SP,=0x40003f00	;堆栈指针被设置为0x40003f00
   ```
   设置堆栈指针（SP）的起始地址，确保程序的堆栈有一个确定的基址。

4. **初始化内存拷贝**：
   ```assembly
   LDR R0,=|Image$$RO$$Limit|
   LDR R1,=|Image$$RW$$Base|
   LDR R3,=|Image$$ZI$$Base|
   CMP R0,R1
   BEQ LOOP1
   ```
   将只读段（`RO`）中的内容复制到读写段（`RW`）中。首先加载只读段末尾地址（`RO$$Limit`），然后加载读写段的基地址（`RW$$Base`）和未初始化数据段的基地址（`ZI$$Base`）。接下来比较两个地址，以确定是否需要继续复制数据。

5. **数据段拷贝循环**：
   ```assembly
   LOOP0
   CMP R1,R3
   LDRCC R2,[R0],#4
   STRCC R2,[R1],#4
   BCC LOOP0
   ```
   这个循环将只读段的数据逐字节拷贝到读写段。每次从 `RO$$Limit` 中读取数据，然后存储到 `RW$$Base` 地址中，直到拷贝完毕。

6. **初始化未初始化数据段**：
   ```assembly
   LOOP1
   LDR R1,=|Image$$ZI$$Limit|
   MOV R2,#0
   LOOP2
   CMP R3,R1
   STRCC R2,[R3],#4
   BCC LOOP2
   ```
   这个循环负责清零未初始化数据段（ZI段）。通过设置一个循环，将从 `ZI$$Base` 到 `ZI$$Limit` 的内存区域清零。

7. **跳转到C程序的主函数**：
   ```assembly
   B MAIN
   ```
   最后，跳转到C程序中的 `main()` 函数开始执行应用程序。

### （2）实验程序中的MAIN()函数是否可以更改为其他名字？

不可以单纯的更改实验程序中的MAIN()函数，**因为要和Startup.s文件中声明的名字保持必须保持一致，并且函数名还要与跳转指令保持一致**，如果要更改，则：

1. **Startup.s 文件中声明的名字必须一致**：
   在 `Startup.s` 文件中，有一条 `IMPORT MAIN` 的指令，表示导入了一个名为 `MAIN` 的函数。如果要更改 `MAIN` 函数的名字，需要在 C 代码中使用相同的新名字，并且还要修改 `IMPORT` 语句和跳转指令。例如，如果将 `MAIN()` 改为 `MyFunc()`，则 `Startup.s` 文件中应改为：
   
   ```assembly
   IMPORT MyFunc
   B MyFunc
   ```
   
2. **函数名要与跳转指令一致**：
   由于 `Startup.s` 中使用了 `B MAIN` 指令来跳转到 `MAIN()` 函数，所以如果更改函数名，也必须相应地修改这条跳转指令，否则程序将无法正确跳转到新的函数。

## 实验3-2 C语言调用汇编程序实验

### （1） 在实验参考程序中，子程序间参数是如何传递的？如果参数数量大于4个，该如何处理？ 

根据ARM的调用规范，函数调用时，前4个参数是通过寄存器 **R0 - R3** 传递的。如果参数的数量超过4个，则多余的参数通过 **堆栈** 传递。

1. **前4个参数通过寄存器传递**：
   - 在汇编子程序 `Add.s` 中，两个整数参数 `x` 和 `y` 被加载到寄存器 `R0` 和 `R1` 中，然后通过 `ADD R0, R0, R1` 实现两个参数的加法运算，结果也被存储在 `R0` 中作为返回值。
   - 寄存器 **R0** 是第一个参数的存放位置，**R1** 是第二个参数的位置，函数执行完后，返回值通过 **R0** 返回。

2. **处理超过4个参数的情况**：
   - 当参数的数量大于4个时，前4个参数会依次存放在 **R0 - R3** 中，剩余的参数则通过堆栈传递。堆栈中的参数从第五个参数开始按照 **先入后出** 的顺序压入堆栈，子程序在需要时从堆栈中读取这些参数。
   - 例如，如果有6个参数，前4个参数在寄存器中，剩余的两个参数通过堆栈传递。子程序可以使用堆栈指针（SP）来访问这些额外的参数。

### （2） 增加加数的数量为8个，修改main.c和add.s，并运行验证，运行结果截图，将程序代码和运行结果截图复制到实验文档中提交。

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20241020162010846.png" alt="image-20241020162010846" style="zoom:50%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20241020162021685.png" alt="image-20241020162021685" style="zoom:50%;" />



## 修改实验2-3编写的求最大公约数指令程序，通过C程序调用，并输出结果。

```c
#define UINT unsigned int
extern UINT gcd_asm(UINT a, UINT b);

int main(void)
{

    gcd_asm(15, 9);
    return 0;
}
```

```assembly
    area cdo,code,readonly  ;段名cdo,代码段
    code32          ;ARM指令
gcd_asm
    GLOBAL  gcd_asm
    MOV     r2, r0     ; 将第一个参数保存到 r2
    MOV     r3, r1     ; 将第二个参数保存到 r3

start 
    CMP     r2, r3     ; 比较 r2 和 r3
    BEQ     end        ; 如果相等，跳转到 end
    SUBLT   r3, r3, r2 ; r3 = r3 - r2 (r2 < r3)
    SUBGT   r2, r2, r3 ; r2 = r2 - r3 (r2 > r3)
    B       start      ; 继续循环

end
    MOV     r0, r2     ; 将结果返回到 r0
    BX      lr         ; 返回

    END
```

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20241020135751336.png" alt="image-20241020135751336" style="zoom:50%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20241020135930273.png" alt="image-20241020135930273" style="zoom:50%;" />

15与9的最大公约数为3，已保存至寄存器`r0`。
