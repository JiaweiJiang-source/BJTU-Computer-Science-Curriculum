## Lecture4 数组和广义表

```c++
//三元组转置
# define MAXSIZE 1000				//设非零元素的个数最多为1000
/*三元组的存储结构*/
typedef struct {
	int row, col;					//该非零元素的行下标和列下标
	int e;							//该非零元素的值
}Triple;
/*三元组表的存储结构*/
typedef struct {
	Triple data[MAXSIZE + 1];		//非零元素的三元组表，下标从1开始
	int m, n, len;					//矩阵的行数、列数和非零元素的个数
}TSMatrix;
/*转置：列序递增转置法*/
void TransposeTSMatrix(TSMatrix* A, TSMatrix* B) {
	int i, j, k;
	B->m = A->n;
	B->n = A->m;
	B->len = A->len;
	if (B->len > 0) {
		j = 1;											//记录转置后的三元组在三元组表B中的下标值
		for (k = 1; k <= A->n; k++) {
			for (i = 1; i < A->len; i++) {				//从头至尾扫描三元组表A，寻找col值为k的三元组进行转置
				if (A->data[i].col == k) {
					B->data[j].row = A->data[i].col;
					B->data[j].col = A->data[i].row;
					B->data[j].e = A->data[i].e;
					j++;
				}
			}
		}
	}
}

```



## Lecture7 树

```c++
// 中序遍历二叉树的非递归算法二 
//先扫描根结点的所有左结点并入栈，出栈一个结点，访问之，然后扫描该结点的右结点并入栈
void inorder(BiTree T)
{
    BiTree *stack[m0], p = T;
    int top = 0;
    do
    {
        while(p!=NULL)
        {
            stack[top++] = p;
            p = p->lchild;
        }
        if(top>=0)
        {
            p = stack[top--];
            cout<<p->data;
            p = p->rchild;
        }
    }while(p!=NULL||top!=0)
}


//前序遍历二叉树的非递归算法
//先扫描根结点的所有左结点并入栈，出栈一个结点，然后扫描该结点的右结点并入栈，再扫描该右结点的所有左结点并入栈；
void preorder(BiTree T)
{
    BiTree *stack[m0],p = T;
    int top = 0;
    if(p!=NULL)
    {
        stack[top++] = p;
        while(top>=0)
        {
            p = stack[top--];
            cout<<p->data;
            if(p->rchild!=NULL)
                stack[++top] = p->rchild;
            if(p->lchild!=NULL)
                stack[++top] = p->lchild;
        }
    }
}

// 后序遍历二叉树的非递归算法
void postorder(BiTree T)
{
    BiTree *stack[m0],p = T;
    int top = 0;
    int tag[m0];// 定义一个数组tag用于标记左右子树是否访问过，top表示栈顶指针
    
    do
    {
        while (p != NULL) // 扫描左结点
        {
            top++;
            stack[top] = p;
            tag[top] = 0;  // 标记为左子树
            p = p->lchild; // 移动到左子树
        }

        while ((top > 0) && tag[top] == 1) // p的左右子树都访问过
        {
            printf("%d ", stack[top]->data); // 访问结点并输出
            top--;                            // 出栈
        }

        p = stack[top];

        if ((top > 0) && (tag[top] == 0)) // 扫描右子树
        {
            p = p->rchild;
            tag[top] = 1; // 标记为右子树
        }

    } while (p != NULL || top != 0); // 当前节点非空或者栈非空时继续循环
}

//层次顺序（同一层次自左至右）遍历算法
//使用队列
void translevel(BiTree b) // 按层次遍历
{
    //定义队列结构体
    struct node
    {
        BiTree vec[MaxSize];
        int f,r;
    }q;
    
    q.f = 0,q.r = 0;
    
    if(b!=NULL)
		cout<<b->data;
    q.vec[q.r++] = b;// 结点指针进入队列
    
    while(q.f<q.r)
    {
        b = q.vec[q.f++];//队头元素出列
        
        if(b->lchild!=NULL)
        {
            cout<<b->lchild->data;
            q.vec[q.r++] = b->lchild;
        }
        if(b->rchild!=NULL)
        {
            cout<<b->rchild->data;
            q.vec[q.r++] = b->rchild;
        }
    }
}

//统计二叉树叶子节点个数
void CountLeaf(BiTree T, int &count)
{
    if(T)
    {
        if((!T->lchlid)&&(!T->rchild))
            count++;
        CountLeaf(T->lchild,count);
        CountLeaf(T->rchild,count);
    }
}

//统计二叉树中叶子结点的个数方法二
int CountLeaf(BiTree T)
{
    if (T == NULL)
        return 0;
    else if (T->lchild == NULL && T->rchild == NULL)
        return 1;
    else
        return CountLeaf(T->lchild) + CountLeaf(T->rchild);
}

//应用二：求二叉树的深度(后序遍历)
int Depth(BiTree T)
{
    if(!T)
        return 0;
    else
    {
        depthLeft = Depth(T->lchild);
        depthright = Depth(T->rchild);
        return depthLeft>depthright?depthLeft+depthright+1;
    }
}

//应用五：建立二叉树的存储结构
Status CreateBiTree(BiTree &T)
{
    cin>>ch;
    if(T==' ')
        T=NULL;
    else
    {
        if(!(T=(BiTNode*)malloc(sizeof(BiTNode))))
            return error;
        T->data = ch;
        CreateBiTree(T->lchild);
        CreateBiTree(T->rchild);
    }
}

//中序遍历二叉线索树T的非递归算法
void InOrderTraverse_Thr(BiThrTree T, void (*Visit)(TElemType e)) {
    p = T->lchild;
    
    while(p!=T){
        while(p-)
    }
    
}

//二叉树的中序线索化过程
void InThreading(BiThrTree p)
{
    if(p)
    {
        InTreading(p->lchild);
        if(!p->lchild)
        {
            p->Ltag = Tread;
            p->lchild = pre;
        }
        
        if(!pre->rchild)
        {
            pre->Ltag = Tread;
            pre->rchild = p;
        }
        pre = p;	//更新前驱节点
        InTreading(p->rchild);
    }
}

Status InOrderThreading (BiThrTree &Thrt, BiThrTree T)
// 函数名：InOrderThreading
// 参数：
//   - Thrt: 中序线索链表的头结点指针，将指向头结点
//   - T: 二叉树的根节点指针
// 返回值：操作执行状态，OK 表示成功
{
    if (!(Thrt = (BiThrTree)malloc(sizeof(BiThrNode))))
        exit(OVERFLOW); // 分配头结点内存，若失败则退出程序

    Thrt->LTag = Link;  // 头结点左标志置为Link，表示指向子节点
    Thrt->RTag = Thread; // 头结点右标志置为Thread，表示线索
    Thrt->rchild = Thrt; // 头结点的右孩子指针指向自身，用于构建循环链表

    return OK; // 返回操作成功状态
} // InOrderThreading

if (!T)  Thrt->lchild = Thrt; // 如果二叉树为空，则将头结点的左孩子指向头结点自身，表示回指
else {             
      Thrt->lchild = T;   pre = Thrt; // 否则，将头结点的左孩子指向根节点T，pre指向头结点
      InThreading(T);        // 对二叉树进行中序遍历，进行中序线索化           
      pre->rchild = Thrt;      // 处理最后一个结点，将中序遍历的最后一个节点的右孩子指向头结点
      pre->RTag = Thread;    // 将最后一个节点的右标志置为线索
      Thrt->rchild = pre;    // 头结点的右孩子指向中序遍历的最后一个节点，构成循环
}


//应用一：求树的深度的算法：
int TreeDepth(CSTree T) {
    if (!T)  
        return 0;
    else {
        h1 = TreeDepth(T->firstchild);    
        h2 = TreeDepth(T->nextsibling);   
        return (max(h1 + 1, h2));
    }
}
```

## Lecture9 排序

```c++
//直接插入排序
void InsertionSort(SqList &L) 
{
    for(int i = 2;i <= L.length; i++)
    {
        if(L.r[i].key<L.r[i-1].key)
            L.r[0] = L.r[i];
        for(int j = i-1; L.r[0]<L.r[j] ;j--)
            L.r[j+1] = L.r[j];
        L.r[j+1] = L.r[0];
    }
}

//折半插入排序
void BiInsertSort(SqList &L)
{
    low = 1, high = i-1;
    while(low<=high)
    {
        m = (low+high)/2;
        if(L.r[0]<L.r[m])
            high = m - 1;
        else
            low = m - 1;
    }
}

//希尔排序
void ShellSort(SqList &L, int dlta[], int t) {
    // 对顺序表 L 作希尔排序,其中 dlta[0..t-1] 存放增量序列，如 5、3、2、1
    for (int k = 0; k < t; ++k) {
        ShellInsert(L, dlta[k]); // 一趟增量为 dlta[k] 的插入排序
    }
} // ShellSort

void ShellInsert(SqList &L, int dk) {
    // 对顺序表 L 作一趟增量为 dk 的希尔排序
    for (int i = dk + 1; i <= n; ++i) {
        if (L.r[i].key < L.r[i - dk].key) { // 若当前元素小于增量 dk 之前的元素
            L.r[0] = L.r[i]; // 暂存当前元素到 L.r[0]
            // 从当前位置向前查找插入位置，间隔为 dk
            for (int j = i - dk; j > 0 && (L.r[0].key < L.r[j].key); j -= dk) {
                L.r[j + dk] = L.r[j]; // 将元素后移
            }
            L.r[j + dk] = L.r[0]; // 将暂存的元素插入到合适位置
        } // if
    }
} // ShellInsert

//冒泡排序
void bubblesort(Elem R[], int n)
{
    int i = n,flag = 1;
    while(i>1 && flag)
    {
        flag = 0;
        for(int j = 1;j < i; j++)
        {
            Swap(a[j],a[j+1]);
            flag = 1;
        }
        i--;
    }
}

//快速排序
int Partition(RedType R[], int low, int high) 
{
    //一趟快排
    R[0] = R[low];//存放枢纽元素
    int pivoclot = R[low].key;
    
    while(low<high)
    {
        while(low<high&&(R[high].key>=pivoclot))
            high--;
        R[low] = R[high];
        while(low<high&&(R[low].key)<pivoclot)
            low++;
        R[high] = R[low];
    }
    R[low] = R[0];
    return low;
}
void QSort(RedType R[], int s, int t)
{
    // 对记录序列 R[s..t] 进行快速排序
    pivotloc = Partition(R,s,t);
    QSort(R,s,pivotloc - 1);
    QSort(R,pivotloc + 1,t);
}

//简单选择排序
void SelectSort(ELEM R[],int n)
{
    for(int i = 1;i<n;i++)
    {
        int j = SelectMinKey(R,i);
        if(i!=min)
            swap(R[i],R[j]);
    }
}

//堆排序
//这段代码实现了对大顶堆的调整操作，用于在给定的堆中，从位置 s 开始向下调整以满足堆的性质。
/*
运行逻辑原理：

HeapAdjust 函数用于调整堆，将从位置 s 开始的堆进行调整，使其满足大顶堆的性质。具体流程如下：

先将位置 s 的元素保存到变量 rc 中。
从 s 的左孩子开始，一直调整到堆的最后一个元素。
在每一次循环中，找到 s 的左右孩子中较大的一个（如果存在），将 s 的值与其进行比较，如果 rc 的关键字比较大，说明已经满足大顶堆的性质，退出循环；否则，将较大的孩子的值赋给 s，并将 s 更新为较大孩子的位置。
最后将 rc 插入到 s 的位置，完成调整。
HeapSort 函数首先利用 HeapAdjust 函数将无序序列构建成大顶堆，然后进行堆排序：

从堆的中间位置（即最后一个非叶子节点）开始，逐个向前调用 HeapAdjust，构建大顶堆。
然后，从堆的末尾开始，依次将堆顶元素与堆尾元素交换，然后对剩余的元素重新调整为大顶堆。
重复上述过程，直到堆中只剩一个元素，排序完成。
*/
void HeapAdjust(RcdType R[], int s, int m) 
{
    // 大顶堆的调整函数
    rc = R[s];//rc存储堆顶元素
    for(int j = 2*s; j <= m ;j *= 2) // 从左孩子开始向下调整
    { 
        if(j<m && R[j].key<R[j+1].key)
            ++j;
        if(rc.key>R[j].key)
            break;
        R[s] = R[j];
        s = j;
    }
    R[s] = rc;// 将调整前的堆顶记录插入到 s 位置，完成调整
}

Typedef SqList HeapType; // 堆采用顺序表存储表示

void HeapSort(HeapType &H) { // 对顺序表 H 进行堆排序
    for (i = H.length / 2; i > 0; --i)
        HeapAdjust(H, i, H.length);
    // 进行堆排序
    for (i = H.length; i > 1; --i) {
        H.r[1] ↔ H.r[i];
        HeapAdjust(H, 1, i - 1);
}
```

