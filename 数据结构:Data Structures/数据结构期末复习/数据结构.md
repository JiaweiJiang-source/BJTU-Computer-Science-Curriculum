# Lecture1 绪论

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301101808811.png" alt="image-20240301101808811" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301101833042.png" alt="image-20240301101833042" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301101901146.png" alt="image-20240301101901146" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301102229270.png" alt="image-20240301102229270" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301102258162.png" alt="image-20240301102258162" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301102318888.png" alt="image-20240301102318888" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301102352644.png" alt="image-20240301102352644" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301102416624.png" alt="image-20240301102416624" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301102505831.png" alt="image-20240301102505831" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301102821697.png" alt="image-20240301102821697" style="zoom:33%;" />

**算法的特性**

有穷性 确定性 可行性 有输入 有输出

**算法设计的原则**

正确性 可读性 健壮性 高效率与低存储量需求





# Lecture2 线性表

顺序存储结构是一种随机存取的存储结构。 

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301101537984.png" alt="image-20240301101537984" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301101548906.png" alt="image-20240301101548906" style="zoom:33%;" />





# Lecture3 栈和队列

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301091744072.png" alt="image-20240301091744072" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301092133556.png" alt="image-20240301092133556" style="zoom:33%;" />

### 栈的应用举例

#### 数制转换

​						<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301092414128.png" alt="image-20240301092414128" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301092703395.png" alt="image-20240301092703395" style="zoom:33%;" />

#### 括号匹配的检验

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301093001668.png" alt="image-20240301093001668" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301093034105.png" alt="image-20240301093034105" style="zoom:33%;" />

#### 表达式求值

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301093416063.png" alt="image-20240301093416063" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301093500892.png" alt="image-20240301093500892" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301093524789.png" alt="image-20240301093524789" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301093649733.png" alt="image-20240301093649733" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301093954112.png" alt="image-20240301093954112" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301094044984.png" alt="image-20240301094044984" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301094053808.png" alt="image-20240301094053808" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301094531499.png" alt="image-20240301094531499" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301094542701.png" alt="image-20240301094542701" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301094713603.png" alt="image-20240301094713603" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301094721771.png" alt="image-20240301094721771" style="zoom:33%;" />

#### 递归函数调用的实现

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301095012182.png" alt="image-20240301095012182" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301095144532.png" alt="image-20240301095144532" style="zoom:33%;" />

### 队列（Queue）

#### 队列的顺序存储结构

**循环队列**

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301095750172.png" alt="image-20240301095750172" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301095801030.png" alt="image-20240301095801030" style="zoom:33%;" />

```c++
Status enqueue(queue &Q,int &e)
{
    if((Q.rear+1)%MaxSize == Q.queue)
        return false;
    Q.queue[Q.rear] = x;
    Q.rear = (Q.rear + 1)%Maxsize;
}

Status dequeue(queue &Q,int &e)
{
    if(Q.front == Q.rear)
        return false;
    e = Q.queue[Q.front];
    Q.front = (Q.front + 1)%Maxsize;
}
```





<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301095623801.png" alt="image-20240301095623801" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301095659444.png" alt="image-20240301095659444" style="zoom:33%;" />

#### 链式存储

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301100230802.png" alt="image-20240301100230802" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240301100247575.png" alt="image-20240301100247575" style="zoom:33%;" />



# Lecture4 串

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229221513283.png" alt="image-20240229221513283" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229221543689.png" alt="image-20240229221543689" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229221601230.png" alt="image-20240229221601230" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229221623446.png" alt="image-20240229221623446" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229221646474.png" alt="image-20240229221646474" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229221708383.png" alt="image-20240229221708383" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229221715996.png" alt="image-20240229221715996" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229221755071.png" alt="image-20240229221755071" style="zoom:33%;" />

### KMP算法

```c++
void get_next(SString &T, int &next[]) {
    // 求模式串 T 的 Next 函数值并存入数组 next
    i = 1; // 初始化 i 为 1，表示当前比较位置
    next[1] = 0; // 初始化 Next 数组的第一个值为 0
    j = 0; // 初始化 j 为 0

    while (i < T[0]) {
        // 循环遍历模式串 T 的每个字符，直到遍历完毕（T[0] 表示模式串的长度）

        if (j == 0 || T[i] == T[j]) {
            // 如果 j 为 0（即当前比较位置为开头）或者当前字符与模式串中 j 位置的字符相等

            ++i; // 移动 i 指针指向下一个字符
            ++j; // 移动 j 指针指向下一个字符
            next[i] = j; // 将当前位置的 Next 值设为 j
        } else
            j = next[j]; // 如果当前字符与模式串中 j 位置的字符不相等，则将 j 移动到 next[j] 的位置
    }
} // get_next

```

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229222338550.png" alt="image-20240229222338550" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229222522593.png" alt="image-20240229222522593" style="zoom:33%;" />





# Lecture5 数组和广义表

#### 稀疏矩阵

三元组	

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229215511230.png" alt="image-20240229215511230" style="zoom:33%;" />

矩阵转置那里有很多的代码，我不知道要不要背，但今天先懒得看了hahh		

#### 十字链表

行下标、列下标、值、行指针、列指针。

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229220513550.png" alt="image-20240229220513550" style="zoom:33%;" />

#### 广义表

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229220617317.png" alt="image-20240229220617317" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229220636260.png" alt="image-20240229220636260" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229221022082.png" alt="image-20240229221022082" style="zoom:33%;" />

# Lecture6 树和二叉树

+ 内容：
  + 树的基本概念；
  + **二叉树的性质**和存储结构；
  + 遍历二叉树和线索二叉树；
  + 树的存储结构和遍历；
  + **哈夫曼树**及其应用； 
+ 重点：
  + 二叉树的结构特点；
  + 二叉树各种存储结构的特点及适用范围；
  + 按各种次序**遍历二叉树**的**递归和非递归算法**；
  + **二叉树的线索化**，在中序线索树上找给定结点的前驱和后继的方法；
  + 树的各种存储结构及其特点；
  + 编写树的各种运算的算法；
  + 建立**最优二叉树**和**哈夫曼编码**的方法。 
+ 难点：按各种次序**遍历二叉树**的**非递归算法**。 



### 二叉树性质

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229162953897.png" alt="image-20240229162953897" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229163428371.png" alt="image-20240229163428371" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229163440246.png" alt="image-20240229163440246" style="zoom:33%;" />

### 二叉树存储结构

二叉链表

三叉链表+parent

双亲链表

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229163818240.png" alt="image-20240229163818240" style="zoom:33%;" />

线索链表

### 二叉树的遍历

+ 先左后右的遍历算法
+ 算法的递归描述
+ 遍历算法的非递归描述
+ 遍历算法的应用举例

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229164047656.png" alt="image-20240229164047656" style="zoom:33%;" />

#### 算法的递归描述

```c++
// 先序遍历二叉树 
void Preorder (BiTree T,
        void( *visit)(TElemType& e))
{                
   if (T) {
      visit(T->data);                   // 访问根结点
      Preorder(T->lchild, visit); // 遍历左子树
      Preorder(T->rchild, visit); // 遍历右子树
   }
}

// 中序遍历二叉树 
void Inorder (BiTree T,
                  void( *visit)(TElemType& e))
{                    
   if (T) {
      Inorder(T->lchild, visit); // 遍历左子树
      visit(T->data);                 // 访问根结点
      Inorder(T->rchild, visit);// 遍历右子树
   }
}

// 后序遍历二叉树 
void Postorder (BiTree T,
                  void( *visit)(TElemType& e))
{                    
   if (T) {
      Postorder(T->lchild, visit); // 遍历左子树
      Postorder(T->rchild, visit);// 遍历右子树
      visit(T->data);                   // 访问根结点
   }
}

```



#### 遍历二叉树的非递归算法

使用栈来实现中序遍历二叉树的基本思想：

假设二叉树采用二叉链表存储，用一个顺序栈保存返回的结点，先扫描**根结点的所有左结点并入栈，出栈一个结点，访问之，**然后扫描该结点的**右结点并入栈**，再扫描该右结点的所有左结点并入栈，如此这样，直到栈空	为止。

```c++
BiTNode *GoFarLeft(BiTree T, Stack *S)
{
    if (!T )  return NULL;
      while (T->lchild ){    // 找到最左下的结点
          Push(S, T);
          T = T->lchild;
       }
      return T;
}

void Inorder_I(BiTree T, void (*visit)
        (TelemType& e))   // 中序遍历二叉树的非递归算法一 
{  Stack *S;
    t = GoFarLeft(T, S);            // 找到最左下的结点
   while(t)
   { visit(t->data);
      if (t->rchild)
         t = GoFarLeft(t->rchild, S);
     else if ( !StackEmpty(S ))    // 栈不空时退栈
        t = Pop(S);
              else    t = NULL;        // 栈空表明遍历结束
    } // while
}// Inorder_I           


// 中序遍历二叉树的非递归算法二 
void inorder( BiTree  b)    
{   
    BiTree *stack[m0],*p;
     int top=0;  
     p=b;
     do
     {
         while (p!=NULL)                   //扫描所有左结点
            {
               stack[++top]=p;
               p=p->lchild;
            }
            if (top>0) 
            {  
                p=stack[top]; 
               //p所指结点为无左子树的结点或其左子树已遍历过
                 top--;
                 printf(“%d”, p->data); //访问结点
                 p=p->rchild;               //扫描右子树
              }
        } while (p!=NULL || top!=0)
    }
}

```

#### 前序遍历的非递归算法 

根先输出,右孩子后输出

先扫描根结点的所有左结点并入栈，出栈一个结点，然后扫描该结点的右结点并入栈，再扫描该右结点的所有左结点并入栈；

```c++
void preorder( BiTree  b) // 前序遍历二叉树的非递归算法
  { BiTree *stack[m0];
     int top;  
     if (b!=NULL)
       { top=1;                   //根结点入栈
          stack[top]=b;
          while (top>0)       //栈不为空时循环
             { p=stack[top];  //退栈并访问该结点
                top--;
                printf(“%d”,p->data);
                 if (p->rchild!=NULL)     //右孩子入栈
                  { top++;
                     stack[top]=p->rchild;}
               if (p->lchild!=NULL)    //左孩子入栈 
                   { top++;
                      stack[top]=p->lchild;
                   }
              }//while
         }//if
    }
```

#### 后序遍历的非递归算法 

```c++
void postorder(BiTree b) // 后序遍历二叉树的非递归算法
{
    BiTree *stack[m0], *p;  // 定义一个数组栈stack用于存储二叉树节点指针，p用于遍历节点
    int tag[m0], top = 0;   // 定义一个数组tag用于标记左右子树是否访问过，top表示栈顶指针

    p = b; // 初始化p为根节点

    do
    {
        while (p != NULL) // 扫描左结点
        {
            top++;
            stack[top] = p;
            tag[top] = 0;  // 标记为左子树
            p = p->lchild; // 移动到左子树
        }

        while ((top > 0) && tag[top] == 1) // p的左右子树都访问过
        {
            printf("%d ", stack[top]->data); // 访问结点并输出
            top--;                            // 出栈
        }

        p = stack[top];

        if ((top > 0) && (tag[top] == 0)) // 扫描右子树
        {
            p = p->rchild;
            tag[top] = 1; // 标记为右子树
        }

    } while (p != NULL || top != 0); // 当前节点非空或者栈非空时继续循环
}

```

#### 按层次顺序（同一层次自左至右）遍历算法

**队列q**,先将二叉树根结点入队列，然后出队列，输出该结点；若它有左子树，便将左子树根结点入队列；若它有右子树，便将右子树根结点入队列，如此直到队列空为止。**因为队列的特点是先进先出**，从而达到按层次顺序遍历二叉树的目的。

```c++
#define MAXLEN 100

void translevel(BiTree b) // 按层次遍历
{
    // 定义队列结构体
    struct node
    {
        BiTree vec[MAXLEN]; // 存储二叉树节点指针的数组
        int f, r;           // 队列的前端和后端指针
    } q;

    q.f = 0;
    q.r = 0; // 置队列为空队列

    if (b != NULL)
        printf("%d", b->data); // 输出根节点的数据
    q.vec[q.r] = b;             // 结点指针进入队列
    q.r = q.r + 1;

    while (q.f < q.r) // 队列不为空
    {
        b = q.vec[q.f]; // 队头出队列
        q.f = q.f + 1;

        if (b->lchild != NULL) // 输出左孩子，并入队列
        {
            printf("%d", b->lchild->data);
            q.vec[q.r] = b->lchild;
            q.r = q.r + 1;
        }

        if (b->rchild != NULL) // 输出右孩子，并入队列
        {
            printf("%d", b->rchild->data);
            q.vec[q.r] = b->rchild;
            q.r = q.r + 1;
        }
    }
}
```

#### 二叉树的应用

```c++
//应用一：	统计二叉树中叶子结点的个数
void CountLeaf(BiTree T, int &count)
{
    if (T) // 如果当前节点非空
    {
        if ((!T->lchild) && (!T->rchild)) // 如果当前节点没有左右子节点，即为叶子节点
            count++; // 对叶子节点计数

        CountLeaf(T->lchild, count); // 递归统计左子树中叶子节点的个数
        CountLeaf(T->rchild, count); // 递归统计右子树中叶子节点的个数
    }
}

//统计二叉树中叶子结点的个数方法二
int CountLeaf(BiTree T)
{
    // 如果当前节点为空，则返回叶子节点个数为0
    if (T == NULL)
        return 0;
    // 如果当前节点的左右孩子均为空，说明当前节点是叶子节点，返回1
    else if (T->lchild == NULL && T->rchild == NULL)
        return 1;
    // 否则，递归地统计左子树和右子树中的叶子节点个数，然后相加返回
    else
        return CountLeaf(T->lchild) + CountLeaf(T->rchild);
}

//应用二：求二叉树的深度(后序遍历)
int Depth(BiTree T)
{
    // 如果当前节点为空，深度为0
    if (!T)
        depthval = 0;
    else
    {
        // 递归计算左子树的深度
        depthLeft = Depth(T->lchild);
        
        // 递归计算右子树的深度
        depthRight = Depth(T->rchild);
        
        // 当前节点深度为左右子树深度的较大值加1
        depthval = 1 + (depthLeft > depthRight ? depthLeft : depthRight);
    }
    // 返回当前节点的深度
    return depthval;
}

//应用五：建立二叉树的存储结构
Status CreateBiTree(BiTree &T) // 按先序输入二叉树结点的值
{
    scanf(&ch); // 从输入中读取一个字符

    if (ch == ' ')
    {
        T = NULL; // 如果字符为空格，表示当前节点为空
    }
    else
    {
        // 如果字符不为空格，分配内存给当前节点
        if (!(T = (BiTNode *)malloc(sizeof(BiTNode))))
            exit(OVERFLOW);

        T->data = ch;           // 生成根结点，将字符赋值给节点的数据域
        CreateBiTree(T->lchild); // 递归构造左子树
        CreateBiTree(T->rchild); // 递归构造右子树
    }

    return OK; // 返回操作成功
} // CreateBiTree

//(2) 根据表达式建相应的二叉树
/*使用两个栈，一个存放叶子或子树，另一个存放运算符
读入一个字符;
如果是数, 建叶子结点，入树栈暂存; 
如果是运算符,则和字符栈的栈顶元素比较优先级:
若当前的优先级“高”，则入运算符栈暂存;
若栈顶的优先级“高”，则运算符栈的栈顶元素出栈(根),从树栈中弹出两个元素(右左孩子)建子树，新建的子树再入树栈保存。*/
void CrtNode(BiTree& T,char ch)
{
   T=(BiTNode*)malloc(sizeof(BiTNode));
   T->data = ch;
   T->lchild = T->rchild = NULL;
   Push( PTR, T );         //叶子结点入PTR树栈保存
}
void CrtSubtree (Bitree& T, char c)
{
   T=(BiTNode*)malloc(sizeof(BiTNode));
   T->data = c;
   Pop(PTR, rc);  T->rchild = rc;  //两个叶子结点出栈
   Pop(PTR, lc);  T->lchild = lc;  //建子树
            //遍历时先左后右，左子树先入栈，所以必须先弹出右子树
   Push(PTR, T);      //子树入PTR树栈保存
}
void CrtExptree(BiTree &T, char exp[] ) 
{ InitStack(S);  Push(S, '#');  InitStack(PTR); 
  p = exp;  ch = *p; // PTR树栈放数和结点，S栈放字符和运算符
  while (!(GetTop(S)=='#' && ch=='#')) {
     if (!IN(ch, OP))   CrtNode( t, ch );//读入的是字符，
                  //建立叶子结点并入栈， #号:表达式的开始和结束， OP:运算符集合
     else {             }           //代表读入的是运算符
     if ( ch!= '#') { p++;  ch = *p;}//未结束时指针后移
     } // while
  Pop(PTR, T);     //从PTR栈中弹出最后的一棵树
} // CrtExptree

switch (ch) {
    case '(' : Push(S, ch); break; //表示读入的ch是“(”
    case ')' : Pop(S, c);               //表示读入的ch是“)”
                   while (c!= '(') {     //栈顶不是“(”
                        CrtSubtree( t, c);  //按栈顶元素建子树并入栈
                        Pop(S, c) ; }
                    break; 
    default :                     //表示读入的ch是其他运算符

} // switch
// default
while(Gettop(S, c) && ( precede(c,ch))) { 
    //栈顶元素c的运算优先级大于刚读入的ch运算符的优先级
    CrtSubtree( t, c);   //按栈顶元素建子树
    Pop(S, c);          //弹出栈顶元素
   }
if ( ch!= '#' ) Push( S, ch);   //将ch运算符入栈
break;

	
```

#### 线索二叉树

什么是线索二叉树

线索链表的遍历算法 

如何建立线索链表

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229173512285.png" alt="image-20240229173512285" style="zoom:33%;" />

```c++
void InOrderTraverse_Thr(BiThrTree T, void (*Visit)(TElemType e)) {
    // T指向头结点，头结点的左链lchild指向根结点
    // 中序遍历二叉线索树T的非递归算法
    p = T->lchild; // p指向根结点

    while (p != T) { // 空树或遍历结束时，p==T
        while (p->LTag == Link) // 第一个结点
            p = p->lchild; // 如果当前结点有左子树，则一直向左走，直到没有左子树

        // 访问左子树为空的结点
        if (!visit(p->data)) 
            return error; // 这里应该是处理错误的方式，可能应该抛出异常或采取其他适当的错误处理方式

        while (p->RTag == Thread && p->rchild != T) {
            p = p->rchild; // 访问后继结点
            visit(p->data); // 访问当前结点
        }
        p = p->rchild; // p进至其右子树根
    }
} // InOrderTraverse_Thr

void InThreading(BiThrTree p)
{
    if (p) // 如果当前节点不为空
    {
        InThreading(p->lchild); // 递归处理左子树
        if (!p->lchild) // 如果左孩子为空，说明当前节点是中序遍历的第一个节点
        {
            p->LTag = Thread; // 将当前节点的左标志置为线索
            p->lchild = pre; // 将当前节点的左孩子指向其前驱节点
        }
        if (!pre->rchild) // 如果前驱节点的右孩子为空，说明当前节点是前驱节点的后继节点
        {
            pre->RTag = Thread; // 将前驱节点的右标志置为线索
            pre->rchild = p; // 将前驱节点的右孩子指向当前节点
        }
        pre = p; // 更新前驱节点为当前节点
        InThreading(p->rchild); // 递归处理右子树
    } // if
} // InThreading
      

Status InOrderThreading (BiThrTree &Thrt, BiThrTree T)
{
    if (!(Thrt = (BiThrTree)malloc(sizeof(BiThrNode))))
        exit(OVERFLOW); // 分配头结点内存，若失败则退出程序

    Thrt->LTag = Link;  // 头结点左标志置为Link，表示指向子节点
    Thrt->RTag = Thread; // 头结点右标志置为Thread，表示线索
    Thrt->rchild = Thrt; // 头结点的右孩子指针指向自身，用于构建循环链表

    return OK; 
} 

if (!T)  Thrt->lchild = Thrt; // 如果二叉树为空，则将头结点的左孩子指向头结点自身，表示回指
else {             
      Thrt->lchild = T;   pre = Thrt; // 否则，将头结点的左孩子指向根节点T，pre指向头结点
      InThreading(T);        // 对二叉树进行中序遍历，进行中序线索化           
      pre->rchild = Thrt;      // 处理最后一个结点，将中序遍历的最后一个节点的右孩子指向头结点
      pre->RTag = Thread;    // 将最后一个节点的右标志置为线索
      Thrt->rchild = pre;    // 头结点的右孩子指向中序遍历的最后一个节点，构成循环
}

```

#### 树的存储结构

双亲表示法

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229174512979.png" alt="image-20240229174512979" style="zoom:33%;" />

孩子表示法

孩子链表表示法

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229174551007.png" alt="image-20240229174551007" style="zoom:33%;" />

树的二叉链表(孩子-兄弟）表示法

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229174626231.png" alt="image-20240229174626231" style="zoom:33%;" />

#### 树和森林的遍历

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229174809870.png" alt="image-20240229174809870" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229174931957.png" alt="image-20240229174931957" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229174957534.png" alt="image-20240229174957534" style="zoom:33%;" />

```c++
//应用一：求树的深度的算法：
int TreeDepth(CSTree T) {
    if (!T)  // 如果树为空，返回深度0
        return 0;
    else {
        // 递归求解左子树和右子树的深度
        h1 = TreeDepth(T->firstchild);    // 左子树深度
        h2 = TreeDepth(T->nextsibling);   // 右子树深度
        // 返回左右子树深度中的较大值加上当前节点的深度（加1）
        return (max(h1 + 1, h2));
    }
} // TreeDepth
```

#### 哈夫曼树

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229175309121.png" alt="image-20240229175309121" style="zoom:33%;" />



# Lecture 7 图

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229175815325.png" alt="image-20240229175815325" style="zoom:33%;" />

极大联通子图是联通分量

极小连通子图是生成树---生成树的集合是生成森林

### 图的存储表示

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229180405905.png" alt="image-20240229180405905" style="zoom:33%;" />

#### 邻接矩阵

只与图中顶点个数有关，而与边的数目无关。

#### 邻接表

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229180620398.png" alt="image-20240229180620398" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229180543208.png" alt="image-20240229180543208" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229182217654.png" alt="image-20240229182217654" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229182253314.png" alt="image-20240229182253314" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229182318041.png" alt="image-20240229182318041" style="zoom:33%;" />

#### 有向图的十字链表存储表示 

有向图的邻接表和逆邻接表结合起来得到的一种链表

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229182701240.png" alt="image-20240229182701240" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229182715529.png" alt="image-20240229182715529" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229182800872.png" alt="image-20240229182800872" style="zoom:33%;" />

### 图的遍历

为此，设辅助数组visited[0..n-1]，初始值置为“假”或者“0”，一旦访问了顶点Vi，便置visited[i]为“真”或者被访问时的次序号。

#### 深度优先搜索遍历图

深度优先搜索遍历连通图的过程类似于树的先根遍历；

```c++
void DFS(Graph G, int v) {
    VisitFunc(v); // 访问第 v 个结点

    visited[v] = TRUE; // 将顶点 v 标记为已访问

    for (w = FirstAdjVex(G, v); w != 0; w = NextAdjVex(G, v, w)) {
        // 遍历顶点 v 的邻接顶点
        if (!visited[w]) // 如果邻接顶点 w 尚未被访问
            DFS(G, w);   // 递归调用 DFS 对邻接顶点 w 进行深度优先搜索
    }
}

void DFSTraverse(Graph G, Status (*Visit)(int v)) {
    VisitFunc = Visit; // 使用全局变量，设置访问函数指针

    // 访问标志数组初始化
    for (v = 0; v < G.vexnum; ++v) 
        visited[v] = FALSE;

    // 对尚未访问的顶点调用DFS
    for (v = 0; v < G.vexnum; ++v) {
        if (!visited[v]) 
            DFS(G, v); // 对尚未访问的顶点 v 调用深度优先搜索算法
    }
}

```

#### 广度优先搜索遍历图

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229183530845.png" alt="image-20240229183530845" style="zoom:33%;" />

```c++
visited[v] = TRUE;  // 将当前顶点 v 标记为已访问
Visit(v);           // 访问顶点 v
EnQueue(Q, v);      // 将顶点 v 入队列

while (!QueueEmpty(Q)) { // 当队列非空时，进行循环，确保访问整个连通子图
    DeQueue(Q, u); // 队头元素出队并置为 u

    // 遍历顶点 u 的所有邻接顶点
    for (w = FirstAdjVex(G, u); w != 0; w = NextAdjVex(G, u, w)) {
        if (!visited[w]) { // 如果邻接顶点 w 尚未被访问过
            visited[w] = TRUE; // 标记顶点 w 为已访问
            Visit(w);          // 访问顶点 w
            EnQueue(Q, w);     // 将访问的顶点 w 入队列
        }
    }
} // while

```

### 遍历应用举例

求一条从顶点 i 到顶点 s 的简单路径------**DFS搜索**

```c++
void DFSearch(int v, int s, char *PATH) {
    visited[v] = TRUE; // 访问第 v 个顶点
    Append(PATH, getVertex(v)); // 第 v 个顶点加入路径

    for (w = FirstAdjVex(v); w != 0 && !found; w = NextAdjVex(v, w)) {
        if (w == s) { // 如果找到了目标顶点 s
            found = TRUE; // 设置 found 标志为 TRUE
            Append(PATH, w); // 将目标顶点 s 加入路径
        } else if (!visited[w]) {
            // 如果邻接顶点 w 尚未被访问，则递归调用 DFSearch 继续搜索
            DFSearch(w, s, PATH);
        }
    }

    if (!found) Delete(PATH); // 如果没有找到到 s 的路径，则删除当前路径
}

```

求两个顶点之间的一条路径长度最短的路径

求路径长度最短的路径可以基于**广度优先搜索遍历**进行。

```c++
typedef DuLinkList QueuePtr; // 定义队列指针类型为 DuLinkList

void InitQueue(LinkQueue& Q) {
    // 初始化队列 Q
    // 分配内存给 Q.front 和 Q.rear，并初始化两者的 next 指针为 NULL
    Q.front = Q.rear = (QueuePtr)malloc(sizeof(QNode));
    Q.front->next = Q.rear->next = NULL;
}

void EnQueue(LinkQueue& Q, QelemType e) {
    // 入队操作
    QueuePtr p = (QueuePtr)malloc(sizeof(QNode)); // 分配内存给新节点 p
    p->data = e; // 赋值给 p 的数据域
    p->next = NULL; // 初始化 p 的 next 指针为 NULL
    p->prior = Q.front; // 将 p 的 prior 指针指向 Q 的头节点
    Q.rear->next = p; // 将 p 加入到 Q 的尾节点之后
    Q.rear = p; // 将 p 设置为 Q 的新尾节点
}

void DeQueue(LinkQueue& Q, QelemType& e) {
    // 出队操作
    Q.front = Q.front->next; // Q 的头节点指向下一个节点
    e = Q.front->data; // 取出头节点的数据域并赋值给 e
}

```

### 图的连通性和生成树

#### 普里姆 (Prim) 法

```c++
struct {
     VertexType  adjvex;  // U集中的顶点序号
     VRType     lowcost;  // 边的权值
} closedge[MAX_VERTEX_NUM];  // closedge数组存储辅助信息，用于构造最小生成树

void MiniSpanTree_P(MGraph G, VertexType u) {
    // 用普里姆算法从顶点u出发构造网G的最小生成树

    k = LocateVex(G, u);  // 获取顶点u在图中的位置索引k

    // 辅助数组初始化
    for (j = 0; j < G.vexnum; ++j) {
        if (j != k)  
            closedge[j] = {u, G.arcs[k][j].adj};  // 初始化辅助数组，设置顶点u到其他顶点的权值
    }

    closedge[k].lowcost = 0;  // 初始，将顶点u并入U集合，设置权值为0

    // 选择其余N-1个顶点
    for (i = 1; i < G.vexnum; ++i) {
        k = minimum(closedge);  // 求出加入生成树的下一个顶点(k)，即找到权值最小的顶点

        // 输出生成树上一条边的两个顶点
        printf(closedge[k].adjvex, G.vexs[k]); 

        closedge[k].lowcost = 0;  // 将第k顶点并入U集

        // 修改其他顶点的最小边
        for (j = 0; j < G.vexnum; ++j) {
            // 新顶点并入U后重新选择最小边
            if (G.arcs[k][j].adj < closedge[j].lowcost) {
                closedge[j] = {G.vexs[k], G.arcs[k][j].adj};  // 更新辅助数组中其他顶点的最小边信息
            }
        }
    }
}

```

#### 克鲁斯卡尔 (Kruskal) 法

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229185554061.png" alt="image-20240229185554061" style="zoom:33%;" />

求最短路径的迪杰斯特拉算法：

设置辅助数组Dist，其中每个分量Dist[k] 表示当前所求得的从源点到其余各顶点 k 的最短路径。



求每一对顶点之间的最短路径

方法一：每次以一个顶点为源点，重复执行迪杰斯特拉算法n次。这样，便可求得每一对顶点之间的最短路径。

#### 弗洛伊德算法

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229190403993.png" alt="image-20240229190403993" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229190809988.png" alt="image-20240229190809988" style="zoom:33%;" />

```c++
// Floyd算法用于求解带权有向图G中任意两点之间的最短路径及路径长度
// 参数说明：
//   G: 图的邻接矩阵表示
//   path: 保存最短路径的二维数组，path[v][w]表示从v到w的最短路径
//   dist: 保存最短路径长度的二维数组，dist[v][w]为从v到w的最短路径长度
void Floyd(MGraph G, link &path[][50], int &dist[][50]) {
    // 初始化最短路径长度矩阵和路径矩阵
    for (v = 0; v < G.vexnum; ++v) {
        for (w = 0; w < G.vexnum; ++w) {
            dist[v][w] = G.arcs[v][w];  // 给dist赋初值为图中各边的权值
            if (dist[v][w] < max) 
                path[v][w] = [v] + [w];  // 如果有边存在，则路径为起点到终点
        }
    }

    // 对角线上的元素为0，表示自身到自身的最短路径长度为0
    for (v = 0; v < G.vexnum; ++v) {
        dist[v][v] = 0;
    }

    // 三重循环遍历所有可能的路径，更新最短路径和路径矩阵
    for (u = 0; u < G.vexnum; ++u) {
        for (v = 0; v < G.vexnum; ++v) {
            for (w = 0; w < G.vexnum; ++w) {
                if (dist[v][u] + dist[u][w] < dist[v][w]) {
                    // 从v经u到w有一条路径更短
                    dist[v][w] = dist[v][u] + dist[u][w];
                    path[v][w] = path[v][u] + path[u][w];  // 更新最短路径
                }
            }
        }
    }
}

```

#### 拓扑排序

用顶点表示活动，用弧表示活动间优先关系的有向图称为AOV(Activity on Vertex)-网。

若网中所有顶点都在它的拓扑有序序列中，则该AOV-网中必定不存在环。

从图中选择一个没有前驱的顶点，（即入度为零的点）且输出之；从图中删除此顶点及其所有由它发出的边；重复⑴、 ⑵两步，直到所有的顶点均已输出，整个拓扑排序完成；或者直到剩下的图中再也没有入度为零的顶点，说明此图是有环图，拓扑排序不能再进行下去了。

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229191216634.png" alt="image-20240229191216634" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229191342267.png" alt="image-20240229191342267" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229191520740.png" alt="image-20240229191520740" style="zoom:33%;" />

```c++
TopologicalSort(ALGraph G) {
    // 有向图采用邻接表存储结构。若G无回路，则输出G的顶点的一个拓扑序列并返回OK，否则ERROR

    // 求各顶点的入度,结果存放在indegree数组中
    FindInDegree(G, indegree);

    // 初始化栈S
    InitStack(S);

    // 将入度为零的顶点入栈
    for (i = 0; i < G.vexnum; ++i)
        if (!indegree[i])
            Push(S, i);

    // 对输出顶点计数
    count = 0;

    // 当栈S非空时循环执行以下操作
    while (!EmptyStack(S)) {
        Pop(S, v);  // 出栈一个顶点v
        ++count;    // 计数加1
        printf(v);  // 输出顶点v

        // 遍历顶点v的所有邻接点w
        for (w = FirstAdj(G, v); w != 0; w = NextAdj(G, v, w)) {
            --indegree[w];          // 将顶点w的入度减1
            if (!indegree[w])
                Push(S, w);         // 若入度变为零，则将顶点w入栈
        }
    }

    // 若输出顶点计数小于图的顶点数，则图中存在回路，否则图无回路
    if (count < G.vexnum)
        printf(“图中有回路ERROR”)
    else
        return OK;
}
```

#### 关键路径

AOE-网(Activity On Edge)

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229192121336.png" alt="image-20240229192121336" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229192144289.png" alt="image-20240229192144289" style="zoom:33%;" />

### 图的存储

```c++
//图的邻接表存储表示：
typedef struct ArcNode {         // 弧结点
    int  adjvex;                           // 该弧所指向的顶点的位置
    struct ArcNode  *nextarc;   // 指向下一条弧的指针
    InfoType  *info;                       // 该弧相关信息的指针
} ArcNode;
typedef struct VNode {            // 头结点
    VertexType  data;                 // 顶点信息
    ArcNode  *firstarc;              // 指向第一条依附该顶点的弧
  } AdjList[MAX_VERTEX_NUM];
typedef struct {                   // 图结构
     AdjList  vertices;            // 表头结点向量
     int      vexnum, arcnum; // 图的当前顶点数和弧数
} ALGraph;

```

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229193237539.png" alt="image-20240229193237539" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229193256206.png" alt="image-20240229193256206" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229193304235.png" alt="image-20240229193304235" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229193346046.png" alt="image-20240229193346046" style="zoom:33%;" />

eg：采用邻接表存储结构，编写一个判别无向图中任意给定的两个顶点之间是否存在一条长度为k的简单路径的算法。

```c++
bool hasSimplePathKLength(Graph G, int src, int dest, int k) {
    // 使用DFS来搜索从源顶点src到目标顶点dest的简单路径
    // 初始时，路径长度为0
    return DFSUtil(G, src, dest, k, 0);
}

bool DFSUtil(Graph G, int src, int dest, int k, int pathLength) {
    // 如果路径长度等于k并且当前顶点是目标顶点，则返回true
    if (pathLength == k && src == dest)
        return true;

    // 如果路径长度小于k，则继续搜索
    if (pathLength < k) {
        // 标记当前顶点为已访问
        G.visited[src] = true;

        // 遍历当前顶点的邻接表
        for (int i = 0; i < G.adjList[src].size(); ++i) {
            int nextVertex = G.adjList[src][i];

            // 如果邻接顶点未访问，则继续DFS搜索
            if (!G.visited[nextVertex]) {
                // 递归调用DFS，路径长度加1
                if (DFSUtil(G, nextVertex, dest, k, pathLength + 1))
                    return true;
            }
        }

        // 回溯时，取消当前顶点的访问标记
        G.visited[src] = false;
    }

    // 如果找不到长度为k的简单路径，则返回false
    return false;
}

```

# Lecture8 查找

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229211249805.png" alt="image-20240229211249805" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229211508554.png" alt="image-20240229211508554" style="zoom:33%;" />

### 静态查找

#### 折半查找

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229211700940.png" alt="image-20240229211700940" style="zoom:33%;" />

折半查找的二叉树为平衡二叉树

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229211811188.png" alt="image-20240229211811188" style="zoom:33%;" />

#### 索引顺序表（分块查找）

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229211900780.png" alt="image-20240229211900780" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229211910758.png" alt="image-20240229211910758" style="zoom:33%;" />

### 动态查找表

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229212006536.png" alt="image-20240229212006536" style="zoom:33%;" />

#### 二叉排序树（BST）

查找

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229212204797.png" alt="image-20240229212204797" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229212220997.png" alt="image-20240229212220997" style="zoom:33%;" />

插入

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229212417592.png" alt="image-20240229212417592" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229212501472.png" alt="image-20240229212501472" style="zoom:33%;" />

删除

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229212611301.png" alt="image-20240229212611301" style="zoom:33%;" />





(3)以其**中序前驱**替代之，然后再删除该前驱结点

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229212720120.png" alt="image-20240229212720120" style="zoom:33%;" />



<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229212818392.png" alt="image-20240229212818392" style="zoom:33%;" />

#### **二叉平衡树**

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229213249998.png" alt="image-20240229213249998" style="zoom:33%;" />

#### B-树

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229213355949.png" alt="image-20240229213355949" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229213503843.png" alt="image-20240229213503843" style="zoom:33%;" />

<u>**关键字的范围**</u>

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229215246036.png" alt="image-20240229215246036" style="zoom:33%;" />



#### 哈希表

```c++
int  hashsize[] = { 997, ... };    
                           // 哈希表容量递增表，一个合适的素数序列
typedef struct {
    ElemType  *elem;    // 数据元素存储基址,动态分配数组
    int  count;                // 当前数据元素个数
    int  sizeindex;         // hashsize[sizeindex]为当前容量
} HashTable;

#define  SUCCESS  1
#define  UNSUCCESS  0
#define  DUPLICATE  -1

Status SearchHash(HashTable H, KeyType K, int &p, int &c) {
    // 在开放定址哈希表 H 中查找关键码为 K 的记录
    p = Hash(K); // p 为待查数据在表中的位置，求得哈希地址

    while (H.elem[p].key != NULLKEY && !EQ(K, H.elem[p].key)) {
        // 若当前位置不为空且关键码不等于 K，发生冲突
        collision(p, ++c); // 求得下一探查地址 p，c 为冲突次数
    }

    if (EQ(K, H.elem[p].key))
        return SUCCESS; // 查找成功，返回待查数据元素位置 p
    else
        return UNSUCCESS; // 查找不成功
}

Status InsertHash(HashTable &H, Elemtype e) {
    c = 0; // c 用以计算冲突次数，其初始值置零
    if (HashSearch(H, e.key, p, c) == SUCCESS)
        return DUPLICATE;
    // 表中已有与 e 有相同关键字的元素

    if (c < hashsize[H.sizeindex] / 2) {
        // 冲突次数 c 未达到上限，（阀值 c 可调）
    } else
        H.elem[p] = e;
    ++H.count;
    return OK;
    // 插入 e
}

```



# Lecture 9 排序

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229194141144.png" alt="image-20240229194141144" style="zoom:33%;" />

### 插入排序

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229201148547.png" alt="image-20240229201148547" style="zoom:33%;" />

#### 直接插入排序

```c++
void InsertionSort(SqList &L) {
    // 对顺序表 L 作直接插入排序
    int i, j;  // 声明循环变量

    for (i = 2; i <= L.length; ++i) {
        if (L.r[i].key < L.r[i-1].key) {
            L.r[0] = L.r[i];  // 复制为监视哨
            for (j = i - 1; L.r[0].key < L.r[j].key; --j) {
                L.r[j+1] = L.r[j];  // 记录后移
            }
            L.r[j+1] = L.r[0];  // 插入到正确位置
        }
    }
} // InsertionSort

```

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229201735147.png" alt="image-20240229201735147" style="zoom:33%;" />

#### 折半插入排序

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229202049284.png" alt="image-20240229202049284" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229202103822.png" alt="image-20240229202103822" style="zoom:33%;" />

O(n2)

#### 希尔排序

```c++
vx
} // ShellInsert

//CSDN
void ShellSort(SqList &L, int dlta[], int t) {
    int k; // 声明循环变量 k

    // 对顺序表 L 作希尔排序,其中 dlta[0..t-1] 存放增量序列，如 5、3、2、1
    for (k = 0; k < t; ++k) {
        ShellInsert(L, dlta[k]); // 一趟增量为 dlta[k] 的插入排序
    }
} // ShellSort

//希尔排序
void ShellSort(int* arr, int n)
{
	int gap = n;
	while (gap>1)
	{
		//每次对gap折半操作
		gap = gap / 2;
		//单趟排序
		for (int i = 0; i < n - gap; ++i)
		{
			int end = i;
			int tem = arr[end + gap];
			while (end >= 0)
			{
				if (tem < arr[end])
				{
					arr[end + gap] = arr[end];
					end -= gap;
				}
				else
				{
					break;
				}
			}
			arr[end + gap] = tem;
		}
	}
}

```

### 交换排序

#### 冒泡排序

```c++
void bubblesort(Elem R[], int n)
// 改进的冒泡排序算法一
{
    int i = n; // 初始化循环变量 i 为 n
    int flag = 1; // flag=1 表示发生了交换

    // 当 i 大于 1 且 flag 为真时执行循环
    while (i > 1 && flag) {
        flag = 0; // 每次开始循环前将 flag 置为 0

        // 内循环，比较相邻元素并交换位置
        for (int j = 1; j < i; j++) {
            if (R[j].key > R[j + 1].key) {
                Swap(R[j], R[j + 1]); // 如果前一个元素大于后一个元素，则交换它们的位置
                flag = 1; // 设置 flag 为 1，表示发生了交换
            }
        }

        i--; // 减小循环范围，每轮排序最后一个元素已经是最大的，无需再比较
    }
}

```

#### 快速排序

```c++
int Partition(RedType R[], int low, int high) {
    // 一趟快速排序算法的改进
    R[0] = R[low]; // 将枢轴元素暂存于 R[0]
    pivotkey = R[low].key; // 记录枢轴的关键字值
    
    while (low < high) {
        while (low < high && R[high].key >= pivotkey)
            --high;
        R[low] = R[high];

        while (low < high && R[low].key <= pivotkey)
            ++low;

        R[high] = R[low];
    } // while

    // 将枢轴元素放回到最终位置
    R[low] = R[0];

    return low; // 返回枢轴最终位置
} // Partition

void QSort(RedType R[], int s, int t) {
    // 对记录序列 R[s..t] 进行快速排序
    if (s < t) { // 判断是否需要继续排序（序列长度大于1）
        pivotloc = Partition(R, s, t); // 对 R[s..t] 进行一次划分，获取枢轴位置

        QSort(R, s, pivotloc - 1); // 对低子序列递归排序，将枢轴左边的子序列进行快速排序
        QSort(R, pivotloc + 1, t); // 对高子序列递归排序，将枢轴右边的子序列进行快速排序
    }
} // QSort

```

### 选择排序

#### 简 单 选 择 排 序

每次从后面选出一个最小值放到最前面

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229204414814.png" alt="image-20240229204414814" style="zoom:33%;" />

其时间复杂度为O(n2)



#### 树形选择排序

时间复杂度为  O(nlog2n)



#### 堆排序

大根堆是升序

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229204651599.png" alt="image-20240229204651599" style="zoom:33%;" />

```c++
//这段代码实现了对大顶堆的调整操作，用于在给定的堆中，从位置 s 开始向下调整以满足堆的性质。
void HeapAdjust(RcdType R[], int s, int m) {
    // 大顶堆的调整函数

    rc = R[s]; // 暂存 R[s]，即将堆顶元素暂存于 rc
    for (j = 2 * s; j <= m; j *= 2) { // 从左孩子开始向下调整
        if (j < m && R[j].key < R[j + 1].key) 
            ++j; // 若右孩子存在且比左孩子大，则指向右孩子

        if (rc.key >= R[j].key) 
            break; // 若 rc 的关键字大于等于当前孩子节点的关键字，则不需要调整了

        R[s] = R[j]; // 将较大的孩子节点上移至父节点的位置
        s = j; // 更新父节点的位置
    }

    R[s] = rc; // 将调整前的堆顶记录插入到 s 位置，完成调整
} // HeapAdjust

Typedef SqList HeapType; // 堆采用顺序表存储表示

void HeapSort(HeapType &H) { // 对顺序表 H 进行堆排序
    // 建立初始大顶堆
    for (i = H.length / 2; i > 0; --i)
        // 把 H.r[1..H.Length] 建成大顶堆
        HeapAdjust(H, i, H.length);

    // 进行堆排序
    for (i = H.length; i > 1; --i) {
        // 将堆顶记录和当前未经排序子序列 H.r[1..i] 中最后一个记录相互交换
        H.r[1] ↔ H.r[i];
        // 将 H.r[1..i-1] 重新调整为大顶堆
        HeapAdjust(H, 1, i - 1);
    }
}

```

#### 归并排序

通常采用的是2-路归并排序。即：将两个位置相邻的记录有序子序列

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229210328850.png" alt="image-20240229210328850" style="zoom:33%;" />

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229210351778.png" alt="image-20240229210351778" style="zoom:33%;" />

```c++
void Merge(RcdType SR[], RcdType &TR[], int i, int m, int n) {
    // 将有序的记录序列 SR[i..m] 和 SR[m+1..n] 归并为有序的记录序列 TR[i..n]

    for (j = m + 1, k = i; i <= m && j <= n; ++k) {
        // 将 SR 中记录由小到大地并入 TR
        if (SR[i].key <= SR[j].key)
            TR[k] = SR[i++]; // 如果 SR[i] 的关键字小于等于 SR[j] 的关键字，则将 SR[i] 复制到 TR[k] 中，然后将 i 指针向后移动一位
        else
            TR[k] = SR[j++]; // 否则将 SR[j] 复制到 TR[k] 中，然后将 j 指针向后移动一位
    }

    if (i <= m)
        TR[k..n] = SR[i..m]; // 将剩余的 SR[i..m] 复制到 TR
    if (j <= n)
        TR[k..n] = SR[j..n]; // 将剩余的 SR[j..n] 复制到 TR
}

```

<img src="C:\Users\37623\AppData\Roaming\Typora\typora-user-images\image-20240229211029666.png" alt="image-20240229211029666" style="zoom:33%;" />